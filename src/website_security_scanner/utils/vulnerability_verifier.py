#!/usr/bin/env python3
"""
Vulnerability Verification Engine
Low-Code Platform Security Scanner

Active verification system to confirm detected vulnerabilities are actually exploitable.

Author: Bachelor Thesis Project - Low-Code Platforms Security Analysis
"""

import re
import requests
from typing import Dict, List, Optional, Any
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
from bs4 import BeautifulSoup

from ..config.settings import config
from ..utils.logger import get_logger
from ..exceptions.scanner_exceptions import AnalysisError

logger = get_logger('vulnerability_verifier')


class VulnerabilityVerifier:
    """Active verification engine for security vulnerabilities"""

    def __init__(self, session: requests.Session):
        self.session = session
        self.verification_results = {}

    def verify_vulnerability(self, vulnerability: Dict[str, Any], url: str, response: requests.Response) -> Dict[str, Any]:
        """
        Verify if a detected vulnerability is actually exploitable

        Args:
            vulnerability: Vulnerability dictionary from scanner
            url: Target URL
            response: Original response object

        Returns:
            Enhanced vulnerability dict with verification results
        """
        vuln_type = vulnerability.get('type', '')
        verified_vuln = vulnerability.copy()

        try:
            # Route to specific verification method
            if 'XSS' in vuln_type or 'Cross-Site Scripting' in vuln_type:
                verified_vuln['verification'] = self._verify_xss(vulnerability, url, response)
            elif 'SQL Injection' in vuln_type:
                verified_vuln['verification'] = self._verify_sqli(vulnerability, url, response)
            elif 'Command Injection' in vuln_type:
                verified_vuln['verification'] = self._verify_command_injection(vulnerability, url, response)
            elif 'Path Traversal' in vuln_type or 'Directory Traversal' in vuln_type:
                verified_vuln['verification'] = self._verify_path_traversal(vulnerability, url, response)
            elif 'Open Redirect' in vuln_type:
                verified_vuln['verification'] = self._verify_open_redirect(vulnerability, url, response)
            elif 'CSRF' in vuln_type:
                verified_vuln['verification'] = self._verify_csrf(vulnerability, url, response)
            elif 'Missing Security Header' in vuln_type:
                verified_vuln['verification'] = self._verify_security_headers(vulnerability, url, response)
            else:
                verified_vuln['verification'] = {
                    'verified': False,
                    'confidence': 'low',
                    'method': 'pattern_match_only',
                    'note': 'No active verification available for this vulnerability type'
                }

        except Exception as e:
            logger.error(f"Verification failed for {vuln_type}: {str(e)}")
            verified_vuln['verification'] = {
                'verified': False,
                'confidence': 'unknown',
                'error': str(e),
                'method': 'failed'
            }

        return verified_vuln

    def _verify_xss(self, vuln: Dict, url: str, response: requests.Response) -> Dict[str, Any]:
        """Verify XSS vulnerability with safe payload testing"""
        # Use a safe, unique payload that won't cause harm
        test_payload = f"xss_test_{hash(url) % 10000}"
        xss_payloads = [
            f'<script>alert("{test_payload}")</script>',
            f'<img src=x onerror=alert("{test_payload}")>',
            f'javascript:alert("{test_payload}")'
        ]

        verified = False
        confidence = 'low'

        for payload in xss_payloads:
            try:
                # Test in URL parameters
                parsed = urlparse(url)
                if parsed.query:
                    params = parse_qs(parsed.query)
                    for param in params:
                        test_params = params.copy()
                        test_params[param] = [payload]
                        test_url = parsed._replace(query=urlencode(test_params, doseq=True)).geturl()

                        test_response = self.session.get(test_url, timeout=5, verify=config.verify_ssl)
                        if test_payload in test_response.text:
                            verified = True
                            confidence = 'high'
                            break

                # Test in form inputs if page has forms
                soup = BeautifulSoup(response.content, 'html.parser')
                forms = soup.find_all('form')

                for form in forms:
                    form_data = {}
                    for input_field in form.find_all(['input', 'textarea']):
                        name = input_field.get('name')
                        if name:
                            form_data[name] = payload

                    if form_data:
                        form_url = urljoin(url, form.get('action', ''))
                        method = form.get('method', 'get').lower()

                        if method == 'post':
                            test_response = self.session.post(form_url, data=form_data, timeout=5, verify=config.verify_ssl)
                        else:
                            test_response = self.session.get(form_url, params=form_data, timeout=5, verify=config.verify_ssl)

                        if test_payload in test_response.text:
                            verified = True
                            confidence = 'high'
                            break

                if verified:
                    break

            except Exception as e:
                logger.debug(f"XSS verification attempt failed: {str(e)}")
                continue

        return {
            'verified': verified,
            'confidence': confidence,
            'method': 'payload_injection_test',
            'payload_used': test_payload if verified else None,
            'note': 'XSS vulnerability confirmed via safe payload injection' if verified else 'Could not verify XSS with safe testing'
        }

    def _verify_sqli(self, vuln: Dict, url: str, response: requests.Response) -> Dict[str, Any]:
        """Verify SQL injection vulnerability"""
        # Use safe SQL test payloads that shouldn't cause actual damage
        sqli_payloads = [
            "' OR '1'='1",
            "1' OR '1'='1' --",
            "1; SELECT * FROM users --"
        ]

        verified = False
        confidence = 'low'

        try:
            parsed = urlparse(url)
            if parsed.query:
                params = parse_qs(parsed.query)

                for param in params:
                    for payload in sqli_payloads:
                        test_params = params.copy()
                        test_params[param] = [payload]
                        test_url = parsed._replace(query=urlencode(test_params, doseq=True)).geturl()

                        try:
                            test_response = self.session.get(test_url, timeout=5, verify=config.verify_ssl)

                            # Look for SQL error patterns
                            error_patterns = [
                                r'sql syntax',
                                r'mysql.*error',
                                r'postgresql.*error',
                                r'oracle.*error',
                                r'sqlserver.*error',
                                r'odbc.*error'
                            ]

                            response_text = test_response.text.lower()
                            if any(re.search(pattern, response_text, re.IGNORECASE) for pattern in error_patterns):
                                verified = True
                                confidence = 'high'
                                break

                        except:
                            continue

                    if verified:
                        break

        except Exception as e:
            logger.debug(f"SQLi verification failed: {str(e)}")

        return {
            'verified': verified,
            'confidence': confidence,
            'method': 'error_response_analysis',
            'note': 'SQL injection confirmed via error response' if verified else 'Could not confirm SQL injection vulnerability'
        }

    def _verify_command_injection(self, vuln: Dict, url: str, response: requests.Response) -> Dict[str, Any]:
        """Verify command injection vulnerability"""
        # Use safe command that should work on most systems but not be harmful
        safe_commands = [
            "echo test_command_injection",
            "whoami",
            "id"
        ]

        verified = False
        confidence = 'low'

        try:
            parsed = urlparse(url)
            if parsed.query:
                params = parse_qs(parsed.query)

                for param in params:
                    for cmd in safe_commands:
                        test_params = params.copy()
                        test_params[param] = [f"; {cmd}"]
                        test_url = parsed._replace(query=urlencode(test_params, doseq=True)).geturl()

                        try:
                            test_response = self.session.get(test_url, timeout=5, verify=config.verify_ssl)

                            # Look for command output in response
                            if cmd in test_response.text or "test_command_injection" in test_response.text:
                                verified = True
                                confidence = 'high'
                                break

                        except:
                            continue

                    if verified:
                        break

        except Exception as e:
            logger.debug(f"Command injection verification failed: {str(e)}")

        return {
            'verified': verified,
            'confidence': confidence,
            'method': 'command_execution_test',
            'note': 'Command injection confirmed via safe command execution' if verified else 'Could not confirm command injection'
        }

    def _verify_path_traversal(self, vuln: Dict, url: str, response: requests.Response) -> Dict[str, Any]:
        """Verify path traversal vulnerability"""
        traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "/etc/passwd",
            "C:\\Windows\\System32\\drivers\\etc\\hosts"
        ]

        verified = False
        confidence = 'low'

        try:
            parsed = urlparse(url)
            if parsed.query:
                params = parse_qs(parsed.query)

                for param in params:
                    for payload in traversal_payloads:
                        test_params = params.copy()
                        test_params[param] = [payload]
                        test_url = parsed._replace(query=urlencode(test_params, doseq=True)).geturl()

                        try:
                            test_response = self.session.get(test_url, timeout=5, verify=config.verify_ssl)

                            # Look for file content patterns
                            content_indicators = [
                                "root:",  # Unix passwd file
                                "# Copyright",  # Windows hosts file
                                "127.0.0.1",  # Hosts file content
                                "localhost"
                            ]

                            if any(indicator in test_response.text for indicator in content_indicators):
                                verified = True
                                confidence = 'high'
                                break

                        except:
                            continue

                    if verified:
                        break

        except Exception as e:
            logger.debug(f"Path traversal verification failed: {str(e)}")

        return {
            'verified': verified,
            'confidence': confidence,
            'method': 'file_access_test',
            'note': 'Path traversal confirmed via file access' if verified else 'Could not confirm path traversal'
        }

    def _verify_open_redirect(self, vuln: Dict, url: str, response: requests.Response) -> Dict[str, Any]:
        """Verify open redirect vulnerability"""
        redirect_payloads = [
            "http://evil.com",
            "//evil.com",
            "https://evil.com"
        ]

        verified = False
        confidence = 'low'

        try:
            parsed = urlparse(url)
            if parsed.query:
                params = parse_qs(parsed.query)

                for param in params:
                    for payload in redirect_payloads:
                        test_params = params.copy()
                        test_params[param] = [payload]
                        test_url = parsed._replace(query=urlencode(test_params, doseq=True)).geturl()

                        try:
                            # Don't actually follow redirects for safety
                            test_response = self.session.get(test_url, timeout=5, verify=config.verify_ssl,
                                                           allow_redirects=False)

                            # Check if redirect occurs
                            if test_response.status_code in [301, 302, 303, 307, 308]:
                                location = test_response.headers.get('Location', '')
                                if payload in location or 'evil.com' in location:
                                    verified = True
                                    confidence = 'high'
                                    break

                        except:
                            continue

                    if verified:
                        break

        except Exception as e:
            logger.debug(f"Open redirect verification failed: {str(e)}")

        return {
            'verified': verified,
            'confidence': confidence,
            'method': 'redirect_test',
            'note': 'Open redirect confirmed via redirect response' if verified else 'Could not confirm open redirect'
        }

    def _verify_csrf(self, vuln: Dict, url: str, response: requests.Response) -> Dict[str, Any]:
        """Verify CSRF vulnerability by checking for CSRF tokens"""
        soup = BeautifulSoup(response.content, 'html.parser')
        forms = soup.find_all('form')

        has_csrf_protection = False
        csrf_tokens_found = []

        # Look for CSRF tokens in forms
        csrf_token_names = [
            'csrf_token', 'csrf', '_token', '_csrf',
            'authenticity_token', 'xsrf_token', 'xsrf'
        ]

        for form in forms:
            for input_field in form.find_all('input'):
                name = input_field.get('name', '').lower()
                if any(token_name in name for token_name in csrf_token_names):
                    has_csrf_protection = True
                    csrf_tokens_found.append(name)

        # Also check for CSRF meta tags
        csrf_meta = soup.find('meta', {'name': re.compile(r'csrf', re.I)})
        if csrf_meta:
            has_csrf_protection = True
            csrf_tokens_found.append('meta_csrf')

        verified = not has_csrf_protection  # If no protection found, vulnerability exists
        confidence = 'high' if csrf_tokens_found else 'medium'

        return {
            'verified': verified,
            'confidence': confidence,
            'method': 'token_analysis',
            'csrf_tokens_found': csrf_tokens_found,
            'note': 'CSRF vulnerability confirmed - no CSRF tokens found' if verified else f'CSRF protection detected via tokens: {csrf_tokens_found}'
        }

    def _verify_security_headers(self, vuln: Dict, url: str, response: requests.Response) -> Dict[str, Any]:
        """Verify missing security headers"""
        headers = response.headers
        missing_headers = []

        critical_headers = [
            'Strict-Transport-Security',
            'Content-Security-Policy',
            'X-Frame-Options',
            'X-Content-Type-Options',
            'X-XSS-Protection'
        ]

        for header in critical_headers:
            if header not in headers:
                missing_headers.append(header)

        verified = len(missing_headers) > 0
        confidence = 'high'

        return {
            'verified': verified,
            'confidence': confidence,
            'method': 'header_analysis',
            'missing_headers': missing_headers,
            'note': f'Missing security headers confirmed: {missing_headers}' if verified else 'All critical security headers present'
        }

    def get_verification_summary(self) -> Dict[str, Any]:
        """Get summary of verification results"""
        total_verified = sum(1 for v in self.verification_results.values() if v.get('verified'))
        high_confidence = sum(1 for v in self.verification_results.values()
                            if v.get('confidence') == 'high')

        return {
            'total_vulnerabilities': len(self.verification_results),
            'verified_vulnerabilities': total_verified,
            'high_confidence_verifications': high_confidence,
            'verification_rate': len(self.verification_results) > 0 and (total_verified / len(self.verification_results)) * 100
        }