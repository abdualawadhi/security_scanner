#!/usr/bin/env python3
"""
Enhanced Vulnerability Data Models

Advanced vulnerability data structures extracted from ultra_low_code_scanner.py
with CVSS scoring, compliance mappings, and enterprise-grade features.

Author: Bachelor Thesis Project - Low-Code Platforms Security Analysis
"""

from dataclasses import dataclass, asdict
from typing import Dict, List, Optional, Any
from datetime import datetime
import uuid
from ..result_standardizer import normalize_severity


@dataclass
class EnhancedVulnerability:
    """
    Enhanced vulnerability data structure with enterprise-grade features.
    """
    id: str
    type: str
    severity: str
    description: str
    platform: str
    url: str
    cvss_score: float
    category: str
    remediation_priority: str
    compliance_mappings: Dict[str, List[str]]
    timestamp: str
    evidence: Optional[Dict[str, Any]] = None
    references: Optional[List[str]] = None
    verification: Optional[Dict[str, Any]] = None
    instances: Optional[List[Dict[str, Any]]] = None
    remediation: Optional[str] = None
    remediation_steps: Optional[List[str]] = None
    
    def __post_init__(self):
        """Generate ID if not provided."""
        if not self.id:
            self.id = str(uuid.uuid4())
        if not self.timestamp:
            self.timestamp = datetime.now().isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return asdict(self)
    
    @classmethod
    def from_basic_vulnerability(cls, vuln: Dict[str, Any], platform: str = None) -> 'EnhancedVulnerability':
        """Convert basic vulnerability to enhanced format."""
        severity = normalize_severity(vuln.get('severity', 'Info'))
        
        # Extract instances if present
        instances = vuln.get('instances')
        
        # Extract remediation information
        remediation = vuln.get('recommendation') or vuln.get('remediation', '')
        
        # Extract remediation steps if provided
        remediation_steps = vuln.get('remediation_steps')
        if not remediation_steps and remediation:
            # Generate basic steps from recommendation if not explicitly provided
            remediation_steps = [remediation]
        
        return cls(
            id=str(uuid.uuid4()),
            type=vuln.get('type', 'Unknown'),
            severity=severity,
            description=vuln.get('description', ''),
            platform=platform or vuln.get('platform', 'Unknown'),
            url=vuln.get('url', ''),
            cvss_score=cls._calculate_cvss_score(severity),
            category=vuln.get('category', 'General'),
            remediation_priority=cls._calculate_priority(severity),
            compliance_mappings=cls._get_compliance_mappings(vuln.get('type', ''), severity),
            timestamp=vuln.get('timestamp', datetime.now().isoformat()),
            evidence=vuln.get('evidence'),
            references=vuln.get('references', []),
            verification=vuln.get('verification'),
            instances=instances,
            remediation=remediation,
            remediation_steps=remediation_steps
        )
    
    @staticmethod
    def _calculate_cvss_score(severity: str) -> float:
        """Calculate CVSS score from severity level."""
        severity_scores = {
            'Critical': 9.5,
            'High': 7.5,
            'Medium': 5.5,
            'Low': 3.5,
            'Info': 1.0
        }
        return severity_scores.get(severity, 5.0)
    
    @staticmethod
    def _calculate_priority(severity: str) -> str:
        """Calculate remediation priority from severity."""
        priority_map = {
            'Critical': 'Immediate',
            'High': 'High',
            'Medium': 'Medium',
            'Low': 'Low',
            'Info': 'Informational'
        }
        return priority_map.get(severity, 'Medium')
    
    @staticmethod
    def _get_compliance_mappings(vuln_type: str, severity: str) -> Dict[str, List[str]]:
        """Get compliance framework mappings for vulnerability."""
        mappings = {
            'OWASP': [],
            'NIST': [],
            'ISO_27001': [],
            'SOC2': [],
            'PCI_DSS': []
        }
        
        # OWASP Top 10 mappings
        owasp_mappings = {
            'xss': ['A03:2021 - Injection'],
            'sql injection': ['A03:2021 - Injection'],
            'csrf': ['A01:2021 - Broken Access Control'],
            'security headers': ['A05:2021 - Security Misconfiguration'],
            'session management': ['A07:2021 - Identification and Authentication Failures'],
            'information disclosure': ['A04:2021 - Insecure Design'],
            'access control': ['A01:2021 - Broken Access Control'],
            'authentication': ['A07:2021 - Identification and Authentication Failures'],
            'authorization': ['A01:2021 - Broken Access Control'],
            'encryption': ['A02:2021 - Cryptographic Failures'],
            'injection': ['A03:2021 - Injection'],
            'insecure design': ['A04:2021 - Insecure Design'],
            'security misconfiguration': ['A05:2021 - Security Misconfiguration'],
            'vulnerable components': ['A06:2021 - Vulnerable and Outdated Components'],
            'logging': ['A09:2021 - Security Logging and Monitoring Failures'],
            'ssrf': ['A10:2021 - Server-Side Request Forgery']
        }
        
        # NIST mappings
        nist_mappings = {
            'xss': ['SI-10'],
            'sql injection': ['SI-10'],
            'csrf': ['SI-10'],
            'security headers': ['SC-7', 'SC-8'],
            'session management': ['IA-2', 'IA-5'],
            'information disclosure': ['SI-3'],
            'access control': ['AC-1', 'AC-2', 'AC-3'],
            'authentication': ['IA-1', 'IA-2', 'IA-3'],
            'encryption': ['SC-8', 'SC-12', 'SC-13'],
            'injection': ['SI-10'],
            'ssrf': ['SC-7']
        }
        
        # ISO 27001 mappings
        iso_mappings = {
            'xss': ['A.14.2.5'],
            'sql injection': ['A.14.2.5'],
            'csrf': ['A.14.2.5'],
            'security headers': ['A.14.2.5'],
            'session management': ['A.9.2.1', 'A.9.2.3'],
            'information disclosure': ['A.13.2.1'],
            'access control': ['A.9.1', 'A.9.2'],
            'authentication': ['A.9.2', 'A.9.3'],
            'encryption': ['A.10.1'],
            'injection': ['A.14.2.5'],
            'ssrf': ['A.14.2.5']
        }
        
        # Map vulnerability type to compliance frameworks
        vuln_type_lower = vuln_type.lower()
        for framework, mapping_dict in [
            ('OWASP', owasp_mappings),
            ('NIST', nist_mappings),
            ('ISO_27001', iso_mappings)
        ]:
            for pattern, controls in mapping_dict.items():
                if pattern in vuln_type_lower:
                    mappings[framework] = controls
                    break
        
        return mappings


@dataclass
class ScanResult:
    """
    Comprehensive scan result structure with enhanced features.
    """
    scan_id: str
    url: str
    platform: str
    timestamp: str
    vulnerability_findings: List[EnhancedVulnerability]
    security_assessment: Dict[str, Any]
    compliance_summary: Dict[str, Any]
    scan_metadata: Dict[str, Any]
    performance_metrics: Dict[str, Any]
    platform_specific_findings: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        """Generate scan ID if not provided."""
        if not self.scan_id:
            self.scan_id = f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:8]}"
        if not self.timestamp:
            self.timestamp = datetime.now().isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        result = {
            'scan_id': self.scan_id,
            'url': self.url,
            'platform': self.platform,
            'timestamp': self.timestamp,
            'vulnerability_findings': [vuln.to_dict() for vuln in self.vulnerability_findings],
            'security_assessment': self.security_assessment,
            'compliance_summary': self.compliance_summary,
            'scan_metadata': self.scan_metadata,
            'performance_metrics': self.performance_metrics
        }
        if self.platform_specific_findings:
            result['platform_specific_findings'] = self.platform_specific_findings
        return result
    
    def get_severity_counts(self) -> Dict[str, int]:
        """Get vulnerability counts by severity."""
        counts = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0, 'Info': 0}
        for vuln in self.vulnerability_findings:
            if vuln.severity in counts:
                counts[vuln.severity] += 1
        return counts
    
    def get_risk_score(self) -> float:
        """Calculate overall risk score."""
        if not self.vulnerability_findings:
            return 0.0
        
        total_cvss = sum(vuln.cvss_score for vuln in self.vulnerability_findings)
        return total_cvss / len(self.vulnerability_findings)
    
    def get_compliance_coverage(self) -> Dict[str, float]:
        """Get compliance coverage percentages."""
        coverage = {}
        total_frameworks = len(['OWASP', 'NIST', 'ISO_27001', 'SOC2', 'PCI_DSS'])
        
        for framework in ['OWASP', 'NIST', 'ISO_27001', 'SOC2', 'PCI_DSS']:
            covered = sum(1 for vuln in self.vulnerability_findings 
                        if vuln.compliance_mappings.get(framework))
            coverage[framework] = (covered / len(self.vulnerability_findings) * 100) if self.vulnerability_findings else 0
        
        return coverage
