"""
Vulnerability Verification Engine

This module provides safe, ethical verification of detected vulnerabilities.
It uses controlled payloads to confirm the exploitability of potential security issues.
"""

import re
import time
import hashlib
from typing import Dict, Any, List, Optional
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse
import requests
from ..utils.logger import get_logger
from ..config.constants import SEVERITY_LEVELS

logger = get_logger(__name__)


class VulnerabilityVerifier:
    """
    Verifies detected vulnerabilities through controlled active testing.
    
    IMPORTANT: This class performs active security testing. Use only on systems
    you have explicit permission to test.
    """
    
    def __init__(self, session: Optional[requests.Session] = None):
        self.session = session or requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Security Scanner Verifier'
        })
        self.verification_timeout = 10
        self.max_retries = 2
        
    def verify_vulnerability(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Main entry point for vulnerability verification.
        
        Args:
            vulnerability: Vulnerability dict with type, url, parameter info
            
        Returns:
            Verification result with confirmed status and evidence
        """
        vuln_type = vulnerability.get('type', '').lower()
        
        verification_methods = {
            'xss': self.verify_xss,
            'cross-site scripting': self.verify_xss,
            'sql injection': self.verify_sql_injection,
            'command injection': self.verify_command_injection,
            'path traversal': self.verify_path_traversal,
            'directory traversal': self.verify_path_traversal,
            'ssrf': self.verify_ssrf,
            'open redirect': self.verify_open_redirect,
            'xxe': self.verify_xxe,
            'csrf': self.verify_csrf,
        }
        
        method = verification_methods.get(vuln_type)
        if not method:
            return {
                'verified': False,
                'confidence': 'tentative',
                'reason': 'No verification method available for this vulnerability type',
                'original_confidence': vulnerability.get('confidence', 'tentative')
            }
        
        try:
            result = method(vulnerability)
            return result
        except Exception as e:
            logger.error(f"Verification error for {vuln_type}: {e}")
            return {
                'verified': False,
                'confidence': 'tentative',
                'reason': f'Verification failed: {str(e)}',
                'error': str(e)
            }
    
    def verify_xss(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify XSS vulnerability using safe payloads.
        
        Uses mathematical expressions and unique markers instead of actual XSS.
        """
        url = vulnerability.get('url', '')
        param = vulnerability.get('parameter', '')
        
        if not url or not param:
            return {'verified': False, 'reason': 'Missing URL or parameter'}
        
        # Generate unique marker
        marker = hashlib.md5(f"{url}{param}{time.time()}".encode()).hexdigest()[:8]
        
        # Safe XSS test payloads (don't actually execute JavaScript)
        test_payloads = [
            f'<script>/*{marker}*/</script>',
            f'<img src=x onerror=/*{marker}*/>',
            f'\"><script>/*{marker}*/</script>',
            f"'><script>/*{marker}*/</script>",
        ]
        
        for payload in test_payloads:
            try:
                # Test GET parameter
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                params[param] = [payload]
                
                new_query = urlencode(params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme, parsed.netloc, parsed.path,
                    parsed.params, new_query, parsed.fragment
                ))
                
                response = self.session.get(test_url, timeout=self.verification_timeout, verify=False)
                
                # Check if payload is reflected unencoded
                if marker in response.text and payload in response.text:
                    return {
                        'verified': True,
                        'confidence': 'certain',
                        'method': 'active_testing',
                        'payload': payload,
                        'evidence': f'Payload reflected unencoded in response',
                        'verification_details': {
                            'marker': marker,
                            'reflected': True,
                            'encoded': False
                        }
                    }
                    
                # Check if marker present but encoded (potential XSS with encoding bypass)
                if marker in response.text:
                    return {
                        'verified': True,
                        'confidence': 'firm',
                        'method': 'active_testing',
                        'payload': payload,
                        'evidence': f'Payload reflected with encoding',
                        'verification_details': {
                            'marker': marker,
                            'reflected': True,
                            'encoded': True
                        }
                    }
                    
            except Exception as e:
                logger.debug(f"XSS verification attempt failed: {e}")
                continue
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No successful payload reflection detected'
        }
    
    def verify_sql_injection(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify SQL Injection using time-based and error-based detection.
        """
        url = vulnerability.get('url', '')
        param = vulnerability.get('parameter', '')
        
        if not url or not param:
            return {'verified': False, 'reason': 'Missing URL or parameter'}
        
        # Time-based blind SQL injection payloads
        time_payloads = [
            "' OR SLEEP(5)--",
            "' OR pg_sleep(5)--",
            "'; WAITFOR DELAY '00:00:05'--",
            "' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
        ]
        
        # Error-based SQL injection payloads
        error_payloads = [
            "'",
            "''",
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
        ]
        
        # Test time-based
        for payload in time_payloads:
            try:
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                params[param] = [payload]
                
                new_query = urlencode(params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme, parsed.netloc, parsed.path,
                    parsed.params, new_query, parsed.fragment
                ))
                
                start_time = time.time()
                response = self.session.get(test_url, timeout=15, verify=False)
                elapsed = time.time() - start_time
                
                # If response takes 4-6 seconds, likely SQLi
                if 4 <= elapsed <= 6:
                    return {
                        'verified': True,
                        'confidence': 'certain',
                        'method': 'time_based_blind',
                        'payload': payload,
                        'evidence': f'Response delayed by {elapsed:.2f}s indicating SQL execution',
                        'verification_details': {
                            'delay': elapsed,
                            'expected_delay': 5.0
                        }
                    }
            except requests.Timeout:
                # Timeout could indicate successful SQLi
                return {
                    'verified': True,
                    'confidence': 'firm',
                    'method': 'time_based_blind',
                    'payload': payload,
                    'evidence': 'Request timeout suggesting SQL delay function execution'
                }
            except Exception as e:
                logger.debug(f"Time-based SQLi test failed: {e}")
                continue
        
        # Test error-based
        sql_error_patterns = [
            r'SQL syntax.*?error',
            r'mysql_fetch',
            r'pg_query',
            r'ORA-\d+',
            r'SQLServer JDBC Driver',
            r'SQLite.Exception',
            r'Unclosed quotation mark',
            r'Microsoft SQL Native Client',
        ]
        
        for payload in error_payloads:
            try:
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                params[param] = [payload]
                
                new_query = urlencode(params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme, parsed.netloc, parsed.path,
                    parsed.params, new_query, parsed.fragment
                ))
                
                response = self.session.get(test_url, timeout=self.verification_timeout, verify=False)
                
                for pattern in sql_error_patterns:
                    if re.search(pattern, response.text, re.IGNORECASE):
                        return {
                            'verified': True,
                            'confidence': 'certain',
                            'method': 'error_based',
                            'payload': payload,
                            'evidence': f'SQL error message detected in response',
                            'verification_details': {
                                'error_pattern': pattern
                            }
                        }
            except Exception as e:
                logger.debug(f"Error-based SQLi test failed: {e}")
                continue
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No SQL injection indicators detected'
        }
    
    def verify_command_injection(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify command injection using safe payloads (e.g., sleep commands).
        """
        url = vulnerability.get('url', '')
        param = vulnerability.get('parameter', '')
        
        if not url or not param:
            return {'verified': False, 'reason': 'Missing URL or parameter'}
        
        # Time-based command injection payloads
        payloads = [
            '; sleep 5',
            '| sleep 5',
            '& sleep 5',
            '`sleep 5`',
            '$(sleep 5)',
        ]
        
        for payload in payloads:
            try:
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                params[param] = [payload]
                
                new_query = urlencode(params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme, parsed.netloc, parsed.path,
                    parsed.params, new_query, parsed.fragment
                ))
                
                start_time = time.time()
                response = self.session.get(test_url, timeout=15, verify=False)
                elapsed = time.time() - start_time
                
                if 4 <= elapsed <= 6:
                    return {
                        'verified': True,
                        'confidence': 'certain',
                        'method': 'time_based',
                        'payload': payload,
                        'evidence': f'Command execution delay of {elapsed:.2f}s detected',
                        'verification_details': {
                            'delay': elapsed,
                            'expected_delay': 5.0
                        }
                    }
            except Exception as e:
                logger.debug(f"Command injection test failed: {e}")
                continue
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No command injection indicators detected'
        }
    
    def verify_path_traversal(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify path traversal by attempting to read common files.
        """
        url = vulnerability.get('url', '')
        param = vulnerability.get('parameter', '')
        
        if not url or not param:
            return {'verified': False, 'reason': 'Missing URL or parameter'}
        
        # Path traversal payloads and their expected content markers
        test_cases = [
            ('../../../../etc/passwd', ['root:', 'bin:', 'daemon:']),
            ('..\\..\\..\\..\\windows\\win.ini', ['[fonts]', '[extensions]']),
            ('../../../../proc/version', ['Linux', 'version']),
        ]
        
        for payload, markers in test_cases:
            try:
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                params[param] = [payload]
                
                new_query = urlencode(params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme, parsed.netloc, parsed.path,
                    parsed.params, new_query, parsed.fragment
                ))
                
                response = self.session.get(test_url, timeout=self.verification_timeout, verify=False)
                
                # Check if any marker is in response
                found_markers = [m for m in markers if m in response.text]
                if len(found_markers) >= 2:
                    return {
                        'verified': True,
                        'confidence': 'certain',
                        'method': 'file_content_detection',
                        'payload': payload,
                        'evidence': f'System file content detected: {", ".join(found_markers)}',
                        'verification_details': {
                            'markers_found': found_markers
                        }
                    }
            except Exception as e:
                logger.debug(f"Path traversal test failed: {e}")
                continue
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No file content indicators detected'
        }
    
    def verify_ssrf(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify SSRF by testing internal URL access patterns.
        """
        url = vulnerability.get('url', '')
        param = vulnerability.get('parameter', '')
        
        if not url or not param:
            return {'verified': False, 'reason': 'Missing URL or parameter'}
        
        # Use safe external canary URLs for SSRF detection
        # Note: In production, use your own callback server
        test_urls = [
            'http://169.254.169.254/latest/meta-data/',  # AWS metadata
            'http://127.0.0.1:80',
            'http://localhost:22',
        ]
        
        baseline_response = None
        try:
            # Get baseline response
            baseline_response = self.session.get(url, timeout=self.verification_timeout, verify=False)
        except Exception:
            pass
        
        for test_url in test_urls:
            try:
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                params[param] = [test_url]
                
                new_query = urlencode(params, doseq=True)
                ssrf_test_url = urlunparse((
                    parsed.scheme, parsed.netloc, parsed.path,
                    parsed.params, new_query, parsed.fragment
                ))
                
                response = self.session.get(ssrf_test_url, timeout=self.verification_timeout, verify=False)
                
                # Check for AWS metadata response
                if 'ami-id' in response.text or 'instance-id' in response.text:
                    return {
                        'verified': True,
                        'confidence': 'certain',
                        'method': 'metadata_access',
                        'payload': test_url,
                        'evidence': 'AWS metadata service accessible via SSRF',
                        'verification_details': {
                            'detected_content': 'aws_metadata'
                        }
                    }
                
                # Check if response differs significantly from baseline
                if baseline_response and len(response.text) > 100:
                    if abs(len(response.text) - len(baseline_response.text)) > 500:
                        return {
                            'verified': True,
                            'confidence': 'firm',
                            'method': 'response_differential',
                            'payload': test_url,
                            'evidence': 'Significant response difference suggests internal URL access',
                            'verification_details': {
                                'response_length_diff': abs(len(response.text) - len(baseline_response.text))
                            }
                        }
            except Exception as e:
                logger.debug(f"SSRF test failed: {e}")
                continue
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No SSRF indicators detected'
        }
    
    def verify_open_redirect(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify open redirect by testing external URL redirection.
        """
        url = vulnerability.get('url', '')
        param = vulnerability.get('parameter', '')
        
        if not url or not param:
            return {'verified': False, 'reason': 'Missing URL or parameter'}
        
        # Test with safe external URL
        test_redirect = 'https://example.com'
        
        try:
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            params[param] = [test_redirect]
            
            new_query = urlencode(params, doseq=True)
            test_url = urlunparse((
                parsed.scheme, parsed.netloc, parsed.path,
                parsed.params, new_query, parsed.fragment
            ))
            
            response = self.session.get(
                test_url, 
                timeout=self.verification_timeout, 
                verify=False,
                allow_redirects=False
            )
            
            # Check for redirect to external URL
            if response.status_code in [301, 302, 303, 307, 308]:
                location = response.headers.get('Location', '')
                if test_redirect in location or 'example.com' in location:
                    return {
                        'verified': True,
                        'confidence': 'certain',
                        'method': 'redirect_following',
                        'payload': test_redirect,
                        'evidence': f'Application redirects to external URL: {location}',
                        'verification_details': {
                            'redirect_location': location,
                            'status_code': response.status_code
                        }
                    }
        except Exception as e:
            logger.debug(f"Open redirect test failed: {e}")
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No open redirect behavior detected'
        }
    
    def verify_xxe(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify XXE vulnerability using external entity injection.
        """
        url = vulnerability.get('url', '')
        
        if not url:
            return {'verified': False, 'reason': 'Missing URL'}
        
        # Safe XXE payload (attempts to read a file)
        xxe_payload = '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/hostname">]>
<data>&xxe;</data>'''
        
        try:
            response = self.session.post(
                url,
                data=xxe_payload,
                headers={'Content-Type': 'application/xml'},
                timeout=self.verification_timeout,
                verify=False
            )
            
            # Check for file content in response
            if len(response.text) > 20 and not '<?xml' in response.text[:100]:
                return {
                    'verified': True,
                    'confidence': 'firm',
                    'method': 'entity_injection',
                    'payload': 'XXE payload',
                    'evidence': 'Potential file content in XML response',
                }
        except Exception as e:
            logger.debug(f"XXE test failed: {e}")
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No XXE indicators detected'
        }
    
    def verify_csrf(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify CSRF vulnerability by checking token implementation.
        """
        url = vulnerability.get('url', '')
        
        if not url:
            return {'verified': False, 'reason': 'Missing URL'}
        
        try:
            # Check for CSRF tokens in forms
            response = self.session.get(url, timeout=self.verification_timeout, verify=False)
            
            csrf_patterns = [
                r'csrf[_-]?token',
                r'authenticity[_-]?token',
                r'__requestverificationtoken',
                r'anti-forgery',
            ]
            
            has_csrf_token = any(
                re.search(pattern, response.text, re.IGNORECASE)
                for pattern in csrf_patterns
            )
            
            if not has_csrf_token:
                # Try to submit form without token
                # This is a simplified check
                return {
                    'verified': True,
                    'confidence': 'firm',
                    'method': 'token_absence',
                    'evidence': 'No CSRF token detected in forms',
                }
            else:
                return {
                    'verified': False,
                    'confidence': 'tentative',
                    'reason': 'CSRF tokens present, further testing needed'
                }
        except Exception as e:
            logger.debug(f"CSRF test failed: {e}")
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'Could not verify CSRF protection'
        }
