"""
Vulnerability Verification Engine

This module provides safe, ethical verification of detected vulnerabilities.
It uses controlled payloads to confirm the exploitability of potential security issues.
"""

import re
import time
import hashlib
import urllib.parse
from typing import Dict, Any, List, Optional
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse
import requests
from ..utils.logger import get_logger
from ..utils.secret_detector import SecretDetector
from ..utils.error_handler import ErrorHandler, SecurityError, ValidationError, NetworkError
from ..config.constants import SEVERITY_LEVELS

logger = get_logger(__name__)


class VulnerabilityVerifier:
    """
    Verifies detected vulnerabilities through controlled active testing.
    
    IMPORTANT: This class performs active security testing. Use only on systems
    you have explicit permission to test.
    """
    
    def __init__(self, session: Optional[requests.Session] = None):
        self.session = session or requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Security Scanner Verifier'
        })
        self.verification_timeout = 10
        self.max_retries = 2
        
        # Security: Define allowed domains for external verification
        self.allowed_test_domains = {'example.com', 'httpbin.org'}
        
        # Security: Rate limiting
        self.request_timestamps = []
        self.max_requests_per_minute = 30
        
        # Advanced secret detection
        self.secret_detector = SecretDetector()
        
        # Comprehensive error handling
        self.error_handler = ErrorHandler(__name__)
        
    def verify_vulnerability(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Main entry point for vulnerability verification.
        
        Args:
            vulnerability: Vulnerability dict with type, url, parameter info
            
        Returns:
            Verification result with confirmed status and evidence
        """
        # Security: Input validation
        validation_result = self._validate_vulnerability_input(vulnerability)
        if not validation_result['valid']:
            return {
                'verified': False,
                'confidence': 'tentative',
                'reason': f'Invalid input: {validation_result["error"]}',
                'original_confidence': vulnerability.get('confidence', 'tentative')
            }
        
        # Security: Rate limiting
        if not self._check_rate_limit():
            return {
                'verified': False,
                'confidence': 'tentative',
                'reason': 'Rate limit exceeded for verification requests',
                'original_confidence': vulnerability.get('confidence', 'tentative')
            }
        
        vuln_type = vulnerability.get('type', '').lower()
        
        # Enhanced matching for vulnerability types
        method = None
        if 'xss' in vuln_type or 'cross-site scripting' in vuln_type:
            method = self.verify_xss
        elif 'sql injection' in vuln_type or 'sqli' in vuln_type:
            method = self.verify_sql_injection
        elif 'command injection' in vuln_type:
            method = self.verify_command_injection
        elif 'path traversal' in vuln_type or 'directory traversal' in vuln_type:
            method = self.verify_path_traversal
        elif 'ssrf' in vuln_type or 'server-side request forgery' in vuln_type:
            method = self.verify_ssrf
        elif 'open redirect' in vuln_type:
            method = self.verify_open_redirect
        elif 'xxe' in vuln_type or 'xml external entity' in vuln_type:
            method = self.verify_xxe
        elif 'csrf' in vuln_type or 'cross-site request forgery' in vuln_type:
            method = self.verify_csrf
        elif 'airtable base id' in vuln_type:
            method = self.verify_airtable_base_id_exposure
        elif 'secret' in vuln_type or 'api key' in vuln_type:
            method = self.verify_potential_secret_in_javascript

        if not method:
            return {
                'verified': False,
                'confidence': 'tentative',
                'reason': f'No verification method available for vulnerability type: {vuln_type}',
                'original_confidence': vulnerability.get('confidence', 'tentative')
            }
        
        try:
            result = method(vulnerability)
            return result
        except Exception as e:
            # Use comprehensive error handling
            error_response = self.error_handler.handle_exception(e, {
                'vulnerability_type': vuln_type,
                'url': vulnerability.get('url', ''),
                'operation': 'verification'
            })
            
            return {
                'verified': False,
                'confidence': 'tentative',
                'reason': 'Verification process encountered an error',
                'error_code': error_response.get('error', {}).get('error_code', 'VERIFICATION_ERROR')
            }
    
    def verify_xss(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify XSS vulnerability using safe payloads.
        
        Uses mathematical expressions and unique markers instead of actual XSS.
        """
        url = vulnerability.get('url', '')
        param = vulnerability.get('parameter', '')
        
        if not url or not param:
            return {'verified': False, 'reason': 'Missing URL or parameter'}
        
        # Generate unique marker
        marker = hashlib.md5(f"{url}{param}{time.time()}".encode()).hexdigest()[:8]
        
        # Safe XSS test payloads (don't actually execute JavaScript)
        test_payloads = [
            f'<script>/*{marker}*/</script>',
            f'<img src=x onerror=/*{marker}*/>',
            f'\"><script>/*{marker}*/</script>',
            f"'><script>/*{marker}*/</script>",
        ]
        
        for payload in test_payloads:
            try:
                # Test GET parameter
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                params[param] = [payload]
                
                new_query = urlencode(params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme, parsed.netloc, parsed.path,
                    parsed.params, new_query, parsed.fragment
                ))
                
                response = self.session.get(test_url, timeout=self.verification_timeout, verify=False)
                
                # Check if payload is reflected unencoded
                if marker in response.text and payload in response.text:
                    return {
                        'verified': True,
                        'confidence': 'certain',
                        'method': 'active_testing',
                        'payload': payload,
                        'evidence': f'Payload reflected unencoded in response',
                        'verification_details': {
                            'marker': marker,
                            'reflected': True,
                            'encoded': False
                        }
                    }
                    
                # Check if marker present but encoded (potential XSS with encoding bypass)
                if marker in response.text:
                    return {
                        'verified': True,
                        'confidence': 'firm',
                        'method': 'active_testing',
                        'payload': payload,
                        'evidence': f'Payload reflected with encoding',
                        'verification_details': {
                            'marker': marker,
                            'reflected': True,
                            'encoded': True
                        }
                    }
                    
            except Exception as e:
                logger.debug(f"XSS verification attempt failed: {e}")
                continue
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No successful payload reflection detected'
        }
    
    def verify_sql_injection(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify SQL Injection using time-based and error-based detection.
        """
        url = vulnerability.get('url', '')
        param = vulnerability.get('parameter', '')
        
        if not url or not param:
            return {'verified': False, 'reason': 'Missing URL or parameter'}
        
        # Time-based blind SQL injection payloads
        time_payloads = [
            "' OR SLEEP(5)--",
            "' OR pg_sleep(5)--",
            "'; WAITFOR DELAY '00:00:05'--",
            "' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
        ]
        
        # Error-based SQL injection payloads
        error_payloads = [
            "'",
            "''",
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
        ]
        
        # Test time-based
        for payload in time_payloads:
            try:
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                params[param] = [payload]
                
                new_query = urlencode(params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme, parsed.netloc, parsed.path,
                    parsed.params, new_query, parsed.fragment
                ))
                
                start_time = time.time()
                response = self.session.get(test_url, timeout=15, verify=False)
                elapsed = time.time() - start_time
                
                # If response takes 4-6 seconds, likely SQLi
                if 4 <= elapsed <= 6:
                    return {
                        'verified': True,
                        'confidence': 'certain',
                        'method': 'time_based_blind',
                        'payload': payload,
                        'evidence': f'Response delayed by {elapsed:.2f}s indicating SQL execution',
                        'verification_details': {
                            'delay': elapsed,
                            'expected_delay': 5.0
                        }
                    }
            except requests.Timeout:
                # Timeout could indicate successful SQLi
                return {
                    'verified': True,
                    'confidence': 'firm',
                    'method': 'time_based_blind',
                    'payload': payload,
                    'evidence': 'Request timeout suggesting SQL delay function execution'
                }
            except Exception as e:
                logger.debug(f"Time-based SQLi test failed: {e}")
                continue
        
        # Test error-based
        sql_error_patterns = [
            r'SQL syntax.*?error',
            r'mysql_fetch',
            r'pg_query',
            r'ORA-\d+',
            r'SQLServer JDBC Driver',
            r'SQLite.Exception',
            r'Unclosed quotation mark',
            r'Microsoft SQL Native Client',
        ]
        
        for payload in error_payloads:
            try:
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                params[param] = [payload]
                
                new_query = urlencode(params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme, parsed.netloc, parsed.path,
                    parsed.params, new_query, parsed.fragment
                ))
                
                response = self.session.get(test_url, timeout=self.verification_timeout, verify=False)
                
                for pattern in sql_error_patterns:
                    if re.search(pattern, response.text, re.IGNORECASE):
                        return {
                            'verified': True,
                            'confidence': 'certain',
                            'method': 'error_based',
                            'payload': payload,
                            'evidence': f'SQL error message detected in response',
                            'verification_details': {
                                'error_pattern': pattern
                            }
                        }
            except Exception as e:
                logger.debug(f"Error-based SQLi test failed: {e}")
                continue
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No SQL injection indicators detected'
        }
    
    def verify_command_injection(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify command injection using safe payloads (e.g., sleep commands).
        """
        url = vulnerability.get('url', '')
        param = vulnerability.get('parameter', '')
        
        if not url or not param:
            return {'verified': False, 'reason': 'Missing URL or parameter'}
        
        # Time-based command injection payloads
        payloads = [
            '; sleep 5',
            '| sleep 5',
            '& sleep 5',
            '`sleep 5`',
            '$(sleep 5)',
        ]
        
        for payload in payloads:
            try:
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                params[param] = [payload]
                
                new_query = urlencode(params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme, parsed.netloc, parsed.path,
                    parsed.params, new_query, parsed.fragment
                ))
                
                start_time = time.time()
                response = self.session.get(test_url, timeout=15, verify=False)
                elapsed = time.time() - start_time
                
                if 4 <= elapsed <= 6:
                    return {
                        'verified': True,
                        'confidence': 'certain',
                        'method': 'time_based',
                        'payload': payload,
                        'evidence': f'Command execution delay of {elapsed:.2f}s detected',
                        'verification_details': {
                            'delay': elapsed,
                            'expected_delay': 5.0
                        }
                    }
            except Exception as e:
                logger.debug(f"Command injection test failed: {e}")
                continue
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No command injection indicators detected'
        }
    
    def verify_path_traversal(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify path traversal by attempting to read common files.
        """
        url = vulnerability.get('url', '')
        param = vulnerability.get('parameter', '')
        
        if not url or not param:
            return {'verified': False, 'reason': 'Missing URL or parameter'}
        
        # Path traversal payloads and their expected content markers
        test_cases = [
            ('../../../../etc/passwd', ['root:', 'bin:', 'daemon:']),
            ('..\\..\\..\\..\\windows\\win.ini', ['[fonts]', '[extensions]']),
            ('../../../../proc/version', ['Linux', 'version']),
        ]
        
        for payload, markers in test_cases:
            try:
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                params[param] = [payload]
                
                new_query = urlencode(params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme, parsed.netloc, parsed.path,
                    parsed.params, new_query, parsed.fragment
                ))
                
                response = self.session.get(test_url, timeout=self.verification_timeout, verify=False)
                
                # Check if any marker is in response
                found_markers = [m for m in markers if m in response.text]
                if len(found_markers) >= 2:
                    return {
                        'verified': True,
                        'confidence': 'certain',
                        'method': 'file_content_detection',
                        'payload': payload,
                        'evidence': f'System file content detected: {", ".join(found_markers)}',
                        'verification_details': {
                            'markers_found': found_markers
                        }
                    }
            except Exception as e:
                logger.debug(f"Path traversal test failed: {e}")
                continue
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No file content indicators detected'
        }
    
    def verify_ssrf(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify SSRF by testing internal URL access patterns.
        """
        url = vulnerability.get('url', '')
        param = vulnerability.get('parameter', '')
        
        if not url or not param:
            return {'verified': False, 'reason': 'Missing URL or parameter'}
        
        # Use safe external canary URLs for SSRF detection
        # Note: In production, use your own callback server
        test_urls = [
            'http://169.254.169.254/latest/meta-data/',  # AWS metadata
            'http://127.0.0.1:80',
            'http://localhost:22',
        ]
        
        baseline_response = None
        try:
            # Get baseline response
            baseline_response = self.session.get(url, timeout=self.verification_timeout, verify=False)
        except Exception:
            pass
        
        for test_url in test_urls:
            try:
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                params[param] = [test_url]
                
                new_query = urlencode(params, doseq=True)
                ssrf_test_url = urlunparse((
                    parsed.scheme, parsed.netloc, parsed.path,
                    parsed.params, new_query, parsed.fragment
                ))
                
                response = self.session.get(ssrf_test_url, timeout=self.verification_timeout, verify=False)
                
                # Check for AWS metadata response
                if 'ami-id' in response.text or 'instance-id' in response.text:
                    return {
                        'verified': True,
                        'confidence': 'certain',
                        'method': 'metadata_access',
                        'payload': test_url,
                        'evidence': 'AWS metadata service accessible via SSRF',
                        'verification_details': {
                            'detected_content': 'aws_metadata'
                        }
                    }
                
                # Check if response differs significantly from baseline
                if baseline_response and len(response.text) > 100:
                    if abs(len(response.text) - len(baseline_response.text)) > 500:
                        return {
                            'verified': True,
                            'confidence': 'firm',
                            'method': 'response_differential',
                            'payload': test_url,
                            'evidence': 'Significant response difference suggests internal URL access',
                            'verification_details': {
                                'response_length_diff': abs(len(response.text) - len(baseline_response.text))
                            }
                        }
            except Exception as e:
                logger.debug(f"SSRF test failed: {e}")
                continue
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No SSRF indicators detected'
        }
    
    def verify_open_redirect(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify open redirect by testing external URL redirection.
        """
        url = vulnerability.get('url', '')
        param = vulnerability.get('parameter', '')
        
        if not url or not param:
            return {'verified': False, 'reason': 'Missing URL or parameter'}
        
        # Test with safe external URL
        test_redirect = 'https://example.com'
        
        try:
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            params[param] = [test_redirect]
            
            new_query = urlencode(params, doseq=True)
            test_url = urlunparse((
                parsed.scheme, parsed.netloc, parsed.path,
                parsed.params, new_query, parsed.fragment
            ))
            
            response = self.session.get(
                test_url, 
                timeout=self.verification_timeout, 
                verify=False,
                allow_redirects=False
            )
            
            # Check for redirect to external URL
            if response.status_code in [301, 302, 303, 307, 308]:
                location = response.headers.get('Location', '')
                if test_redirect in location or 'example.com' in location:
                    return {
                        'verified': True,
                        'confidence': 'certain',
                        'method': 'redirect_following',
                        'payload': test_redirect,
                        'evidence': f'Application redirects to external URL: {location}',
                        'verification_details': {
                            'redirect_location': location,
                            'status_code': response.status_code
                        }
                    }
        except Exception as e:
            logger.debug(f"Open redirect test failed: {e}")
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No open redirect behavior detected'
        }
    
    def verify_xxe(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify XXE vulnerability using external entity injection.
        """
        url = vulnerability.get('url', '')
        
        if not url:
            return {'verified': False, 'reason': 'Missing URL'}
        
        # Safe XXE payload (attempts to read a file)
        xxe_payload = '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/hostname">]>
<data>&xxe;</data>'''
        
        try:
            response = self.session.post(
                url,
                data=xxe_payload,
                headers={'Content-Type': 'application/xml'},
                timeout=self.verification_timeout,
                verify=False
            )
            
            # Check for file content in response
            if len(response.text) > 20 and not '<?xml' in response.text[:100]:
                return {
                    'verified': True,
                    'confidence': 'firm',
                    'method': 'entity_injection',
                    'payload': 'XXE payload',
                    'evidence': 'Potential file content in XML response',
                }
        except Exception as e:
            logger.debug(f"XXE test failed: {e}")
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'No XXE indicators detected'
        }
    
    def verify_csrf(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify CSRF vulnerability by checking token implementation.
        """
        url = vulnerability.get('url', '')
        
        if not url:
            return {'verified': False, 'reason': 'Missing URL'}
        
        try:
            # Check for CSRF tokens in forms
            response = self.session.get(url, timeout=self.verification_timeout, verify=False)
            
            csrf_patterns = [
                r'csrf[_-]?token',
                r'authenticity[_-]?token',
                r'__requestverificationtoken',
                r'anti-forgery',
            ]
            
            has_csrf_token = any(
                re.search(pattern, response.text, re.IGNORECASE)
                for pattern in csrf_patterns
            )
            
            if not has_csrf_token:
                # Try to submit form without token
                # This is a simplified check
                return {
                    'verified': True,
                    'confidence': 'firm',
                    'method': 'token_absence',
                    'evidence': 'No CSRF token detected in forms',
                }
            else:
                return {
                    'verified': False,
                    'confidence': 'tentative',
                    'reason': 'CSRF tokens present, further testing needed'
                }
        except Exception as e:
            logger.debug(f"CSRF test failed: {e}")
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'Could not verify CSRF protection'
        }
    
    def verify_airtable_base_id_exposure(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify Airtable Base ID exposure using safe pattern validation only.
        
        Args:
            vulnerability: Vulnerability dict with base ID information
            
        Returns:
            Verification result with confirmed status and evidence
        """
        try:
            url = vulnerability.get('url', '')
            description = vulnerability.get('description', '')
            
            # Extract Base ID from description
            base_id_match = re.search(r'app[a-zA-Z0-9]{15}', description)
            if not base_id_match:
                return {
                    'verified': False,
                    'confidence': 'tentative',
                    'reason': 'Could not extract Base ID from vulnerability description'
                }
            
            base_id = base_id_match.group(0)
            
            # Security: Only validate format, don't make external API calls
            # This prevents information disclosure to external services
            if re.match(r'^app[a-zA-Z0-9]{15}$', base_id):
                # Additional validation: check for common patterns
                if not self._is_likely_false_positive_base_id(base_id):
                    return {
                        'verified': True,
                        'confidence': 'firm',
                        'method': 'pattern_validation',
                        'evidence': f'Base ID {base_id} matches valid Airtable Base ID format',
                        'verification_details': {
                            'base_id': base_id[:8] + '...',  # Partial ID for privacy
                            'pattern': '^app[a-zA-Z0-9]{15}$',
                            'note': 'Format validation only - no external verification performed'
                        }
                    }
                else:
                    return {
                        'verified': False,
                        'confidence': 'tentative',
                        'reason': 'Base ID appears to be a false positive',
                        'verification_details': {
                            'base_id': base_id[:8] + '...',
                            'reason': 'Matches false positive patterns'
                        }
                    }
            
        except Exception as e:
            logger.error(f"Airtable Base ID verification error: {e}")
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'Could not verify Airtable Base ID exposure'
        }
    
    def _is_likely_false_positive_base_id(self, base_id: str) -> bool:
        """Check if Base ID is likely a false positive"""
        # Common false positive patterns
        false_positive_patterns = [
            'app0000000000000',  # All zeros
            'app1111111111111',  # All ones
            'app1234567890123',  # Sequential
            'appaaaaaaaaaaaaa',  # All same letter
        ]
        
        # Check for obvious patterns
        if base_id.lower() in false_positive_patterns:
            return True
        
        # Check for low entropy (repeated characters)
        if len(set(base_id.lower())) < 5:  # Less than 5 unique characters
            return True
        
        return False
    
    def verify_potential_secret_in_javascript(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify potential secrets in JavaScript by analyzing the context and format.
        
        Args:
            vulnerability: Vulnerability dict with secret information
            
        Returns:
            Verification result with confirmed status and evidence
        """
        try:
            url = vulnerability.get('url', '')
            description = vulnerability.get('description', '')
            
            # Extract the potential secret from description or parameter
            potential_secret = vulnerability.get('parameter', '')
            if not potential_secret:
                # Try to extract from description
                import re
                patterns = [
                    r'Potential secret found in JavaScript: ([^\s]+)',
                    r'Airtable API key exposed: ([^\s\.]+)',
                    r'Secret "([^"]+)"',
                    r'key exposed: ([^\s\.]+)'
                ]
                for pattern in patterns:
                    match = re.search(pattern, description)
                    if match:
                        potential_secret = match.group(1)
                        break
            
            if not potential_secret:
                return {
                    'verified': False,
                    'confidence': 'tentative',
                    'reason': 'Could not extract secret from vulnerability info'
                }
            
            # Analyze the secret characteristics
            secret_analysis = self._analyze_secret_characteristics(potential_secret)
            
            # Try to fetch the JavaScript content to verify the secret exists
            content = None
            try:
                response = self.session.get(url, timeout=self.verification_timeout)
                if response.status_code == 200:
                    content = response.text
            except Exception as e:
                logger.debug(f"JavaScript content verification failed: {e}")
            
            # Use advanced secret detection if we have content
            if content:
                detected_secrets = self.secret_detector.detect_secrets(content, url)
                
                # Look for our specific secret in the detected secrets
                for detected in detected_secrets:
                    if detected['value'] == potential_secret:
                        return {
                            'verified': True,
                            'confidence': detected['confidence'],
                            'method': 'advanced_detection',
                            'evidence': f'Secret "{potential_secret[:10]}..." confirmed with advanced analysis',
                            'verification_details': {
                                'secret': potential_secret[:10] + '...',  # Partial for privacy
                                'secret_type': detected['type'],
                                'confidence': detected['confidence'],
                                'rank_score': detected.get('rank_score', 0),
                                'detection_method': detected['detection_method'],
                                'url': url
                            }
                        }
            
            # Fallback: Use the original analysis method
            secret_analysis = self._analyze_secret_characteristics(potential_secret)
            
            if secret_analysis['is_suspicious']:
                return {
                    'verified': True,
                    'confidence': secret_analysis['confidence'],
                    'method': 'pattern_analysis',
                    'evidence': f'Secret "{potential_secret[:10]}..." matches suspicious pattern',
                    'verification_details': {
                        'secret': potential_secret[:10] + '...',
                        'secret_type': secret_analysis['type'],
                        'analysis': secret_analysis
                    }
                }
            
        except Exception as e:
            logger.error(f"JavaScript secret verification error: {e}")
        
        return {
            'verified': False,
            'confidence': 'tentative',
            'reason': 'Could not verify potential secret in JavaScript'
        }
    
    def _analyze_secret_characteristics(self, secret: str) -> Dict[str, Any]:
        """Analyze secret characteristics to determine likelihood of being a real secret"""
        analysis = {
            'is_suspicious': False,
            'confidence': 'tentative',
            'type': 'unknown'
        }
        
        # Check for common secret patterns
        patterns = {
            'api_key': r'^[a-zA-Z0-9]{20,}$',
            'jwt_token': r'^[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+$',
            'uuid': r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$',
            'hex_32': r'^[0-9a-f]{32}$',
            'base64': r'^[A-Za-z0-9+/]{20,}={0,2}$',
            'bubble_id': r'^[0-9]{13,}x[0-9]+$',  # Bubble.io IDs
        }
        
        for secret_type, pattern in patterns.items():
            if re.match(pattern, secret):
                analysis['is_suspicious'] = True
                analysis['type'] = secret_type
                analysis['confidence'] = 'firm' if secret_type in ['api_key', 'jwt_token'] else 'tentative'
                break
        
        # Check for suspicious substrings
        suspicious_substrings = ['key', 'token', 'secret', 'password', 'auth']
        if any(sub in secret.lower() for sub in suspicious_substrings):
            analysis['is_suspicious'] = True
            analysis['confidence'] = 'tentative'
            if analysis['type'] == 'unknown':
                analysis['type'] = 'suspicious_string'
        
        # Check length
        if len(secret) >= 20:
            analysis['is_suspicious'] = True
            if analysis['confidence'] == 'tentative':
                analysis['confidence'] = 'firm'
        
        return analysis
    
    def _validate_vulnerability_input(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate vulnerability input to prevent security issues.
        
        Args:
            vulnerability: Vulnerability dictionary to validate
            
        Returns:
            Dictionary with validation result
        """
        try:
            # Check required fields
            if not isinstance(vulnerability, dict):
                return {'valid': False, 'error': 'Input must be a dictionary'}
            
            vuln_type = vulnerability.get('type', '')
            if not isinstance(vuln_type, str) or len(vuln_type) > 100:
                return {'valid': False, 'error': 'Invalid vulnerability type'}
            
            url = vulnerability.get('url', '')
            if url:
                # Validate URL format and safety
                parsed = urlparse(url)
                if not parsed.scheme or not parsed.netloc:
                    return {'valid': False, 'error': 'Invalid URL format'}
                
                # Check for dangerous protocols
                if parsed.scheme not in ['http', 'https']:
                    return {'valid': False, 'error': 'Only HTTP/HTTPS URLs are allowed'}
                
                # Check for localhost/private IPs (prevent internal network scanning)
                host = parsed.netloc.split(':')[0]
                if self._is_private_or_localhost(host):
                    return {'valid': False, 'error': 'Private network URLs are not allowed'}
            
            # Validate parameter if present
            param = vulnerability.get('parameter', '')
            if param and not isinstance(param, str):
                return {'valid': False, 'error': 'Parameter must be a string'}
            
            return {'valid': True}
            
        except Exception as e:
            logger.error(f"Input validation error: {e}")
            return {'valid': False, 'error': 'Validation failed'}
    
    def _is_private_or_localhost(self, host: str) -> bool:
        """Check if host is private IP or localhost"""
        try:
            import ipaddress
            ip = ipaddress.ip_address(host)
            return ip.is_private or ip.is_loopback
        except ValueError:
            # Not an IP address, check hostname patterns
            private_patterns = [
                'localhost', '127.0.0.1', '0.0.0.0',
                '10.', '192.168.', '172.16.', '172.17.', '172.18.', '172.19.',
                '172.20.', '172.21.', '172.22.', '172.23.', '172.24.', '172.25.',
                '172.26.', '172.27.', '172.28.', '172.29.', '172.30.', '172.31.'
            ]
            return any(host.startswith(pattern) for pattern in private_patterns)
    
    def _check_rate_limit(self) -> bool:
        """Check if verification requests are within rate limits"""
        current_time = time.time()
        
        # Remove old timestamps (older than 1 minute)
        self.request_timestamps = [
            ts for ts in self.request_timestamps 
            if current_time - ts < 60
        ]
        
        # Check if under limit
        if len(self.request_timestamps) >= self.max_requests_per_minute:
            return False
        
        # Add current timestamp
        self.request_timestamps.append(current_time)
        return True
    
    def _is_safe_test_domain(self, url: str) -> bool:
        """Check if URL points to a safe test domain"""
        try:
            parsed = urlparse(url)
            domain = parsed.netloc.lower()
            return any(safe in domain for safe in self.allowed_test_domains)
        except Exception:
            return False
