#!/usr/bin/env python3
"""
Common Vulnerability Detection Mixin

Provides shared vulnerability detection methods to reduce code duplication
across all platform analyzers.

Author: Bachelor Thesis Project - Low-Code Platforms Security Analysis
"""

import re
import requests
from typing import Dict, Any, List, Optional
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from bs4 import BeautifulSoup

from .vulnerability_detection import (
    XSSDetector,
    SQLInjectionDetector,
    CSRFDetector,
    OpenRedirectDetector,
)
from ..utils.evidence_builder import EvidenceBuilder


class CommonVulnerabilityMixin:
    """
    Mixin providing common vulnerability detection methods.
    
    This mixin contains shared vulnerability detection logic that can be
    used by all platform analyzers to reduce code duplication and ensure
    consistent detection across platforms.
    """
    
    def __init__(self):
        """Initialize common vulnerability detectors."""
        # These will be initialized by the main analyzer class
        self.xss_detector = None
        self.sqli_detector = None
        self.csrf_detector = None
        self.redirect_detector = None
    
    def initialize_vulnerability_detectors(self, session: requests.Session):
        """Initialize vulnerability detectors with the provided session."""
        self.xss_detector = XSSDetector(session)
        self.sqli_detector = SQLInjectionDetector(session)
        self.csrf_detector = CSRFDetector(session)
        self.redirect_detector = OpenRedirectDetector(session)
    
    def detect_common_vulnerabilities(self, url: str, response: requests.Response,
                                    html_content: str, js_content: str) -> List[Dict[str, Any]]:
        """
        Detect common web vulnerabilities across all platforms.
        
        Args:
            url: Target URL
            response: HTTP response
            html_content: HTML content
            js_content: JavaScript content
            
        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []
        
        if not all([self.xss_detector, self.sqli_detector, self.csrf_detector, self.redirect_detector]):
            return vulnerabilities
        
        # XSS Detection
        xss_vulns = self._detect_xss_vulnerabilities(url, response, html_content)
        vulnerabilities.extend(xss_vulns)
        
        # SQL Injection Detection
        sqli_vulns = self._detect_sql_injection_vulnerabilities(url, response)
        vulnerabilities.extend(sqli_vulns)
        
        # CSRF Detection
        csrf_vulns = self._detect_csrf_vulnerabilities(url, response, html_content)
        vulnerabilities.extend(csrf_vulns)
        
        # Open Redirect Detection
        redirect_vulns = self._detect_open_redirect_vulnerabilities(url, response, html_content)
        vulnerabilities.extend(redirect_vulns)
        
        return vulnerabilities
    
    def _detect_xss_vulnerabilities(self, url: str, response: requests.Response,
                                   html_content: str) -> List[Dict[str, Any]]:
        """Detect XSS vulnerabilities."""
        vulnerabilities = []
        
        try:
            # Reflected XSS
            xss_vulns = self.xss_detector.detect_reflected_xss(url, response, html_content)
            for vuln in xss_vulns:
                vulnerability = self._create_standard_vulnerability(
                    vuln['type'],
                    vuln['severity'],
                    f"{vuln['type']} detected in parameter '{vuln['parameter']}'",
                    f"Parameter: {vuln['parameter']}, Context: {vuln['context']}",
                    url,
                    vuln.get('parameter', ''),
                    category="Cross-Site Scripting",
                    owasp="A03:2021 - Injection",
                    cwe=["CWE-79"],
                    background="Cross-Site Scripting (XSS) occurs when untrusted data is included in web pages without proper validation or escaping, allowing attackers to execute malicious scripts in victims' browsers.",
                    impact="XSS can lead to session hijacking, defacement, malware distribution, data theft, and credential harvesting. Attackers can impersonate users, perform actions on their behalf, and steal sensitive data.",
                    references=[
                        "https://owasp.org/www-community/attacks/xss/",
                        "https://cwe.mitre.org/data/definitions/79.html",
                        "https://portswigger.net/web-security/cross-site-scripting"
                    ],
                    context=vuln.get('context', ''),
                    evidence_type="reflected_xss"
                )
                vulnerabilities.append(vulnerability)
            
            # DOM-based XSS
            dom_xss_vulns = self.xss_detector.detect_dom_xss(url, js_content)
            for vuln in dom_xss_vulns:
                vulnerability = self._create_standard_vulnerability(
                    vuln['type'],
                    vuln['severity'],
                    f"{vuln['type']} detected via DOM manipulation",
                    f"Source: {vuln['source']}, Sink: {vuln['sink']}",
                    url,
                    vuln.get('parameter', ''),
                    category="Cross-Site Scripting",
                    owasp="A03:2021 - Injection",
                    cwe=["CWE-79"],
                    background="DOM-based XSS vulnerabilities occur when the DOM is modified in an unsafe way using untrusted data from sources like location.hash or document.URL.",
                    impact="DOM-based XSS is particularly dangerous as it bypasses server-side protections. Attackers can execute arbitrary JavaScript in the victim's browser context.",
                    references=[
                        "https://owasp.org/www-community/attacks/DOM_Based_XSS",
                        "https://portswigger.net/web-security/cross-site-scripting/dom-based"
                    ],
                    source=vuln.get('source', ''),
                    sink=vuln.get('sink', ''),
                    evidence_type="dom_xss"
                )
                vulnerabilities.append(vulnerability)
                
        except Exception as e:
            # Log error but don't stop the analysis
            pass
        
        return vulnerabilities
    
    def _detect_sql_injection_vulnerabilities(self, url: str, response: requests.Response) -> List[Dict[str, Any]]:
        """Detect SQL injection vulnerabilities."""
        vulnerabilities = []
        
        try:
            sqli_vulns = self.sqli_detector.detect_sql_injection(url, response)
            for vuln in sqli_vulns:
                if vuln['type'] == 'SQL Injection':
                    vulnerability = self._create_standard_vulnerability(
                        vuln['type'],
                        vuln['severity'],
                        f"{vuln['type']} vulnerability detected in parameter '{vuln.get('parameter', 'unknown')}'",
                        f"Parameter: {vuln.get('parameter', 'unknown')}",
                        url,
                        vuln.get('parameter', ''),
                        category="Injection",
                        owasp="A03:2021 - Injection",
                        cwe=["CWE-89"],
                        background="SQL Injection occurs when untrusted user input is included in SQL queries without proper sanitization, allowing attackers to manipulate database queries.",
                        impact="SQL injection can lead to data breaches, data loss, authentication bypass, privilege escalation, and in severe cases, complete server compromise.",
                        references=[
                            "https://owasp.org/www-community/attacks/SQL_Injection",
                            "https://cwe.mitre.org/data/definitions/89.html",
                            "https://portswigger.net/web-security/sql-injection"
                        ],
                        evidence_type="sql_injection"
                    )
                    vulnerabilities.append(vulnerability)
                    
                elif vuln['type'] == 'SQL Error Disclosure':
                    vulnerability = self._create_standard_vulnerability(
                        vuln['type'],
                        vuln['severity'],
                        "Database error messages are being disclosed to users",
                        "SQL error patterns found in response",
                        url,
                        '',
                        category="Information Disclosure",
                        owasp="A05:2021 - Security Misconfiguration",
                        cwe=["CWE-209"],
                        background="SQL error messages can reveal database structure, table names, column names, and implementation details to attackers.",
                        impact="SQL error disclosure assists attackers in crafting more precise SQL injection attacks and understanding the database schema.",
                        references=[
                            "https://cwe.mitre.org/data/definitions/209.html",
                            "https://owasp.org/www-project-web-security-testing-guide/"
                        ],
                        evidence_type="sql_error_disclosure"
                    )
                    vulnerabilities.append(vulnerability)
                    
        except Exception as e:
            # Log error but don't stop the analysis
            pass
        
        return vulnerabilities
    
    def _detect_csrf_vulnerabilities(self, url: str, response: requests.Response,
                                  html_content: str) -> List[Dict[str, Any]]:
        """Detect CSRF vulnerabilities."""
        vulnerabilities = []
        
        try:
            soup = BeautifulSoup(html_content, 'html.parser')
            csrf_vulns = self.csrf_detector.detect_csrf(url, response, soup)
            
            for vuln in csrf_vulns:
                if vuln['type'] == 'Cross-Site Request Forgery (CSRF)':
                    vulnerability = self._create_standard_vulnerability(
                        vuln['type'],
                        vuln['severity'],
                        f"{vuln['type']} vulnerability in form {vuln['form_index']}",
                        f"Form: {vuln['form_method']} {vuln['form_action']}, Missing: {vuln['missing_protection']}",
                        url,
                        '',
                        category="Cross-Site Request Forgery",
                        owasp="A01:2021 - Broken Access Control",
                        cwe=["CWE-352"],
                        background="CSRF attacks force authenticated users to execute unwanted actions on a web application without their consent.",
                        impact="CSRF can lead to unauthorized transactions, password changes, email modifications, data deletion, and privilege escalation.",
                        references=[
                            "https://owasp.org/www-community/attacks/csrf",
                            "https://cwe.mitre.org/data/definitions/352.html",
                            "https://portswigger.net/web-security/csrf"
                        ],
                        form_index=vuln.get('form_index', ''),
                        form_method=vuln.get('form_method', ''),
                        form_action=vuln.get('form_action', ''),
                        evidence_type="csrf"
                    )
                    vulnerabilities.append(vulnerability)
                    
                elif vuln['type'] == 'Weak CSRF Protection':
                    vulnerability = self._create_standard_vulnerability(
                        vuln['type'],
                        vuln['severity'],
                        f"{vuln['type']} in form {vuln['form_index']}",
                        f"Form: {vuln['form_method']} {vuln['form_action']}, Issue: {vuln['issue']}",
                        url,
                        '',
                        category="Cross-Site Request Forgery",
                        owasp="A01:2021 - Broken Access Control",
                        cwe=["CWE-352"],
                        background="Weak CSRF protection may not prevent all CSRF attack vectors, especially in cross-origin scenarios.",
                        impact="Weak CSRF protection can still allow attackers to perform unauthorized actions on behalf of authenticated users, compromising data integrity.",
                        references=[
                            "https://owasp.org/www-community/attacks/csrf",
                            "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite"
                        ],
                        form_index=vuln.get('form_index', ''),
                        issue=vuln.get('issue', ''),
                        evidence_type="weak_csrf"
                    )
                    vulnerabilities.append(vulnerability)
                    
                elif vuln['type'] == 'API CSRF Vulnerability':
                    vulnerability = self._create_standard_vulnerability(
                        vuln['type'],
                        vuln['severity'],
                        f"{vuln['type']} in API endpoint",
                        f"Method: {vuln['method']}, Issue: {vuln['issue']}",
                        url,
                        '',
                        category="Cross-Site Request Forgery",
                        owasp="A01:2021 - Broken Access Control",
                        cwe=["CWE-352"],
                        background="API endpoints may be vulnerable to CSRF if they don't implement proper CSRF protection mechanisms.",
                        impact="API CSRF vulnerabilities can lead to unauthorized API calls, data modification, and privilege escalation.",
                        references=[
                            "https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html"
                        ],
                        method=vuln.get('method', ''),
                        issue=vuln.get('issue', ''),
                        evidence_type="api_csrf"
                    )
                    vulnerabilities.append(vulnerability)
                    
        except Exception as e:
            # Log error but don't stop the analysis
            pass
        
        return vulnerabilities
    
    def _detect_open_redirect_vulnerabilities(self, url: str, response: requests.Response,
                                            html_content: str) -> List[Dict[str, Any]]:
        """Detect open redirect vulnerabilities."""
        vulnerabilities = []
        
        try:
            soup = BeautifulSoup(html_content, 'html.parser')
            redirect_vulns = self.redirect_detector.detect_open_redirect(url, response, soup)
            
            for vuln in redirect_vulns:
                if vuln['type'] == 'Open Redirect':
                    vulnerability = self._create_standard_vulnerability(
                        vuln['type'],
                        vuln['severity'],
                        f"{vuln['type']} vulnerability detected in parameter '{vuln['parameter']}'",
                        f"Parameter: {vuln['parameter']}",
                        url,
                        vuln.get('parameter', ''),
                        category="URL Redirection",
                        owasp="A01:2021 - Broken Access Control",
                        cwe=["CWE-601"],
                        background="Open redirect vulnerabilities occur when an application accepts user-controllable input that specifies a redirect URL without proper validation.",
                        impact="Attackers can redirect users to phishing sites, malware distribution, or malicious content, bypassing URL filtering and trust indicators.",
                        references=[
                            "https://cwe.mitre.org/data/definitions/601.html",
                            "https://owasp.org/www-project-web-security-testing-guide/"
                        ],
                        evidence_type="open_redirect"
                    )
                    vulnerabilities.append(vulnerability)
                    
                elif vuln['type'] == 'Open Redirect via Meta Refresh':
                    vulnerability = self._create_standard_vulnerability(
                        vuln['type'],
                        vuln['severity'],
                        "Open redirect via meta refresh tag detected",
                        "Meta refresh with user-controlled URL parameter",
                        url,
                        '',
                        category="URL Redirection",
                        owasp="A01:2021 - Broken Access Control",
                        cwe=["CWE-601"],
                        background="Meta refresh tags can be abused for open redirect attacks if they incorporate user-controlled input.",
                        impact="Similar to standard open redirects, this can be used for phishing and malware distribution, exploiting user trust.",
                        references=[
                            "https://cwe.mitre.org/data/definitions/601.html"
                        ],
                        evidence_type="meta_refresh_redirect"
                    )
                    vulnerabilities.append(vulnerability)
                    
                elif vuln['type'] == 'Potential Open Redirect via JavaScript':
                    vulnerability = self._create_standard_vulnerability(
                        vuln['type'],
                        vuln['severity'],
                        "Potential open redirect via JavaScript detected",
                        "JavaScript redirect code with user input",
                        url,
                        '',
                        category="URL Redirection",
                        owasp="A01:2021 - Broken Access Control",
                        cwe=["CWE-601"],
                        background="JavaScript-based redirects can be exploited for phishing if they incorporate user-controlled input without validation.",
                        impact="Attackers can craft malicious URLs that redirect victims to phishing sites or malicious content, exploiting user trust.",
                        references=[
                            "https://cwe.mitre.org/data/definitions/601.html"
                        ],
                        evidence_type="javascript_redirect"
                    )
                    vulnerabilities.append(vulnerability)
                    
        except Exception as e:
            # Log error but don't stop the analysis
            pass
        
        return vulnerabilities
    
    def check_common_security_headers(self, response: requests.Response) -> List[Dict[str, Any]]:
        """Check for common security headers across all platforms."""
        vulnerabilities = []
        
        try:
            # Content Security Policy
            csp = response.headers.get("Content-Security-Policy", "")
            if not csp:
                vulnerability = self._create_standard_vulnerability(
                    "Missing Content Security Policy",
                    "Low",
                    "No CSP header found",
                    "",
                    response.url,
                    '',
                    category="Security Headers",
                    owasp="A05:2021 - Security Misconfiguration",
                    cwe=["CWE-693"],
                    background="Content Security Policy (CSP) helps prevent cross-site scripting attacks by restricting which resources can be loaded.",
                    impact="Without CSP, the application is more vulnerable to XSS attacks and data injection attacks.",
                    references=[
                        "https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP",
                        "https://owasp.org/www-project-secure-headers/"
                    ],
                    evidence_type="missing_header"
                )
                vulnerabilities.append(vulnerability)
            
            # X-Frame-Options
            xfo = response.headers.get("X-Frame-Options", "")
            if not xfo:
                vulnerability = self._create_standard_vulnerability(
                    "Missing Clickjacking Protection",
                    "Low",
                    "No X-Frame-Options header",
                    "",
                    response.url,
                    '',
                    category="Security Headers",
                    owasp="A05:2021 - Security Misconfiguration",
                    cwe=["CWE-693"],
                    background="X-Frame-Options header protects against clickjacking attacks by controlling whether the site can be embedded in iframes.",
                    impact="Without this header, the application may be vulnerable to clickjacking attacks.",
                    references=[
                        "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options"
                    ],
                    evidence_type="missing_header"
                )
                vulnerabilities.append(vulnerability)
            
            # Strict-Transport-Security
            hsts = response.headers.get("Strict-Transport-Security", "")
            if not hsts:
                vulnerability = self._create_standard_vulnerability(
                    "Missing HSTS Header",
                    "Low",
                    "No HSTS header found",
                    "",
                    response.url,
                    '',
                    category="Security Headers",
                    owasp="A05:2021 - Security Misconfiguration",
                    cwe=["CWE-523"],
                    background="HTTP Strict Transport Security (HSTS) ensures that browsers only communicate with the site over HTTPS.",
                    impact="Without HSTS, the application may be vulnerable to SSL stripping attacks.",
                    references=[
                        "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security"
                    ],
                    evidence_type="missing_header"
                )
                vulnerabilities.append(vulnerability)
                
        except Exception as e:
            # Log error but don't stop the analysis
            pass
        
        return vulnerabilities
    
    def check_common_information_disclosure(self, js_content: str, html_content: str,
                                         response: requests.Response) -> List[Dict[str, Any]]:
        """Check for common information disclosure issues."""
        vulnerabilities = []
        
        try:
            content = js_content + html_content
            
            # Error patterns
            error_patterns = [
                (r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}', "Email address"),
                (r'\b(?:10|127|172\.(?:1[6-9]|2[0-9]|3[0-1])|192\.168)\..*?\b', "Private IP address"),
                (r'(?i)error[:\s]+["\']([^"\']+)["\']', "Error message"),
                (r'(?i)exception[:\s]+["\']([^"\']+)["\']', "Exception message"),
                (r'(?i)stack\s*trace', "Stack trace"),
            ]
            
            for pattern, desc in error_patterns:
                matches = re.findall(pattern, content)
                if matches:
                    vulnerability = self._create_standard_vulnerability(
                        "Information Disclosure",
                        "Info",
                        f"Potential {desc} disclosure found in client-side content",
                        f"Found {len(matches)} instance(s) of {desc}",
                        response.url,
                        '',
                        category="Information Disclosure",
                        owasp="A09:2021 - Security Logging and Monitoring Failures",
                        cwe=["CWE-200"],
                        background="Information disclosure occurs when sensitive information is exposed to unauthorized parties.",
                        impact="Exposed information can help attackers understand the application structure and plan more targeted attacks.",
                        references=[
                            "https://owasp.org/www-project-top-ten/2021/A09_2021-Security_Logging_and_Monitoring_Failures/"
                        ],
                        evidence_type="information_disclosure"
                    )
                    vulnerabilities.append(vulnerability)
                    break  # Only report once per type to avoid noise
                    
        except Exception as e:
            # Log error but don't stop the analysis
            pass
        
        return vulnerabilities
