#!/usr/bin/env python3
"""
Advanced Vulnerability Detection Module
Low-Code Platform Security Scanner

Comprehensive vulnerability detection with Burp Suite-aligned capabilities
including XSS, SQLi, CSRF, Open Redirect, and other traditional web vulnerabilities.

This module provides active and passive vulnerability detection methods with
detailed request/response analysis and evidence collection.

Author: Bachelor Thesis Project - Low-Code Platforms Security Analysis
"""

import re
import secrets
from typing import Any, Dict, List, Optional, Tuple
from urllib.parse import parse_qs, urlparse, urljoin, unquote

import requests
from bs4 import BeautifulSoup


class XSSDetector:
    """
    Comprehensive Cross-Site Scripting (XSS) detection.
    
    Tests for reflected XSS, stored XSS, DOM-based XSS with multiple
    payload sets and context-aware analysis.
    """

    # XSS payload sets for different contexts
    REFLECTED_PAYLOADS = [
        # Script injection
        '<script>alert("XSS")</script>',
        '<ScRiPt>alert("XSS")</sCrIpT>',
        '<img src=x onerror=alert("XSS")>',
        '<img src=x onerror=alert(1)>',
        '<svg onload=alert("XSS")>',
        '<body onload=alert("XSS")>',
        '<input onfocus=alert("XSS") autofocus>',
        '<details open ontoggle=alert("XSS")>',
        '<iframe src="javascript:alert(\'XSS\')">',
        
        # Event handlers
        '<div onmouseover="alert(\'XSS\')">Hover me</div>',
        '<a href="javascript:alert(\'XSS\')">Click me</a>',
        '<button onclick="alert(\'XSS\')">Click</button>',
        
        # Attribute injection
        '"><script>alert("XSS")</script>',
        "'><script>alert('XSS')</script>",
        '" onmouseover="alert(\'XSS\')" "',
        
        # HTML entity encoded
        '&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;',
        
        # Unicode encoded
        '\\u003cscript\\u003ealert("XSS")\\u003c/script\\u003e',
        
        # Base64 encoded
        '<script>eval(atob("YWxlcnQoJ1hTUycp"))</script>',
        
        # Template literal
        '`<script>alert("XSS")</script>`',
        
        # Less common vectors
        '<marquee onstart=alert("XSS")>',
        '<isindex action="javascript:alert(\'XSS\')" type=submit>',
    ]

    DOM_PAYLOADS = [
        '"><img src=x onerror=alert(document.domain)>',
        '#<img src=x onerror=alert(1)>',
        '?param=<script>alert(1)</script>',
        'javascript:alert(1)',
        'data:text/html,<script>alert(1)</script>',
    ]

    def __init__(self, session: requests.Session):
        self.session = session
        self.detected_xss: List[Dict[str, Any]] = []

    def detect_reflected_xss(
        self, url: str, response: requests.Response, html_content: str
    ) -> List[Dict[str, Any]]:
        """
        Detect reflected XSS vulnerabilities.
        
        Args:
            url: Target URL
            response: HTTP response
            html_content: HTML content to analyze
            
        Returns:
            List of detected XSS vulnerabilities
        """
        vulnerabilities = []
        parsed_url = urlparse(url)
        params = parse_qs(parsed_url.query)
        
        # Test each parameter with XSS payloads
        for param_name, param_values in params.items():
            for param_value in param_values:
                # Check if parameter value is reflected in response
                if self._is_reflected(param_value, html_content):
                    # Determine the reflection context
                    context = self._determine_reflection_context(param_value, html_content)
                    
                    # Test with XSS payloads
                    xss_found = self._test_xss_payloads(url, param_name, param_value, context)
                    
                    if xss_found:
                        vuln = {
                            "type": "Reflected Cross-Site Scripting (XSS)",
                            "severity": "High",
                            "parameter": param_name,
                            "url": url,
                            "context": context,
                            "reflection": param_value[:100],
                            "payloads_tested": len(self.REFLECTED_PAYLOADS),
                            "detection_method": "active_payload_testing",
                        }
                        vulnerabilities.append(vuln)
                        self.detected_xss.append(vuln)
        
        return vulnerabilities

    def detect_dom_xss(
        self, url: str, js_content: str
    ) -> List[Dict[str, Any]]:
        """
        Detect DOM-based XSS vulnerabilities.
        
        Args:
            url: Target URL
            js_content: JavaScript content to analyze
            
        Returns:
            List of detected DOM XSS vulnerabilities
        """
        vulnerabilities = []
        
        # DOM XSS sources and sinks
        sources = [
            r'location\.hash',
            r'location\.search',
            r'document\.URL',
            r'document\.url',
            r'document\.location',
            r'document\.referrer',
            r'window\.name',
            r'history\.pushState',
            r'history\.replaceState',
            r'postMessage',
        ]
        
        sinks = [
            r'\.innerHTML\s*=',
            r'\.outerHTML\s*=',
            r'insertAdjacentHTML',
            r'document\.write\s*\(',
            r'document\.writeln\s*\(',
            r'\beval\s*\(',
            r'setTimeout\s*\(',
            r'setInterval\s*\(',
            r'execScript',
            r'\.setAttribute\s*\(',
        ]
        
        # Check for dangerous patterns
        for source_pattern in sources:
            for sink_pattern in sinks:
                if re.search(source_pattern, js_content, re.IGNORECASE) and \
                   re.search(sink_pattern, js_content, re.IGNORECASE):
                    vuln = {
                        "type": "DOM-based Cross-Site Scripting (XSS)",
                        "severity": "High",
                        "source": source_pattern,
                        "sink": sink_pattern,
                        "url": url,
                        "detection_method": "static_analysis",
                    }
                    vulnerabilities.append(vuln)
                    self.detected_xss.append(vuln)
                    break
        
        return vulnerabilities

    def _is_reflected(self, value: str, content: str) -> bool:
        """Check if a value is reflected in the response content."""
        # URL decode and check multiple variations
        variations = [value, unquote(value), unquote(unquote(value))]
        for variation in variations:
            if variation and variation.lower() in content.lower():
                return True
        return False

    def _determine_reflection_context(self, value: str, html_content: str) -> str:
        """
        Determine the context of reflection (HTML, attribute, JavaScript, etc.).
        """
        # Look for patterns in HTML
        patterns = [
            (r'<[^>]*{re.escape(value)}[^>]*>', 'HTML Tag Attribute'),
            (r'<script[^>]*>.*?{re.escape(value)}.*?</script>', 'JavaScript Code'),
            (r'<style[^>]*>.*?{re.escape(value)}.*?</style>', 'CSS'),
            (r'href=["\']?{re.escape(value)}', 'href Attribute'),
            (r'src=["\']?{re.escape(value)}', 'src Attribute'),
            (r'on\w+\s*=\s*["\']?{re.escape(value)}', 'Event Handler'),
            (r'value=["\']?{re.escape(value)}', 'Input Value'),
        ]
        
        for pattern, context in patterns:
            try:
                if re.search(pattern.format(re=re, value=re.escape(value)), html_content, re.IGNORECASE | re.DOTALL):
                    return context
            except Exception:
                continue
        
        return 'Unknown Context'

    def _test_xss_payloads(
        self, url: str, param_name: str, original_value: str, context: str
    ) -> bool:
        """
        Test XSS payloads by sending requests and analyzing responses.
        """
        parsed_url = urlparse(url)
        base_params = parse_qs(parsed_url.query)
        
        # Test a subset of payloads relevant to the context
        test_payloads = self.REFLECTED_PAYLOADS[:10]  # Test first 10 payloads
        
        for payload in test_payloads:
            # Create test URL with payload
            test_params = {k: v[:] for k, v in base_params.items()}
            test_params[param_name] = [payload]
            
            # Reconstruct URL with new parameters
            from urllib.parse import urlencode
            test_url = urlunparse(parsed_url._replace(query=urlencode(test_params, doseq=True)))
            
            try:
                response = self.session.get(test_url, timeout=10)
                response_text = response.text
                
                # Check if payload is reflected
                if self._is_reflected(payload, response_text):
                    return True
            except Exception:
                continue
        
        return False


class SQLInjectionDetector:
    """
    SQL Injection detection with multiple payload sets and error analysis.
    """

    # SQL injection payloads
    SQLI_PAYLOADS = [
        # Error-based
        "'",
        "' OR '1'='1",
        "' OR '1'='1' --",
        "' OR '1'='1' /*",
        "' OR 1=1 --",
        "' OR 1=1#",
        "1' OR '1'='1",
        "admin' --",
        
        # Union-based
        "' UNION SELECT NULL,NULL,NULL --",
        "' UNION SELECT 1,2,3 --",
        "' UNION SELECT username,password FROM users --",
        "1' UNION SELECT NULL--",
        
        # Boolean-based
        "' AND 1=1 --",
        "' AND 1=2 --",
        "' AND '1'='1' --",
        "' AND '1'='2' --",
        
        # Time-based
        "' AND SLEEP(5) --",
        "' AND BENCHMARK(5000000,MD5(1)) --",
        "1'; WAITFOR DELAY '0:0:5' --",
        
        # Stacked queries
        "'; DROP TABLE users--",
        "'; EXEC xp_cmdshell('dir') --",
    ]

    SQL_ERROR_PATTERNS = [
        r"You have an error in your SQL syntax",
        r"Warning: mysql_fetch_array\(\)",
        r"Warning: pg_exec\(\)",
        r"ORA-\d{5}",
        r"Microsoft OLE DB Provider for ODBC Drivers",
        r"Unclosed quotation mark after the character string",
        r"Syntax error converting the nvarchar value",
        r"PostgreSQL query failed",
        r"SQLite error",
        r"SQLite3::SQLException",
    ]

    def __init__(self, session: requests.Session):
        self.session = session
        self.detected_sqli: List[Dict[str, Any]] = []

    def detect_sql_injection(
        self, url: str, response: requests.Response
    ) -> List[Dict[str, Any]]:
        """
        Detect SQL injection vulnerabilities.
        
        Args:
            url: Target URL
            response: HTTP response
            
        Returns:
            List of detected SQL injection vulnerabilities
        """
        vulnerabilities = []
        parsed_url = urlparse(url)
        params = parse_qs(parsed_url.query)
        
        # Test each parameter
        for param_name, param_values in params.items():
            for param_value in param_values:
                # Test with SQLi payloads
                sqli_found = self._test_sqli_payloads(url, param_name, param_value)
                
                if sqli_found:
                    vuln = {
                        "type": "SQL Injection",
                        "severity": "Critical",
                        "parameter": param_name,
                        "url": url,
                        "detection_method": "active_payload_testing",
                    }
                    vulnerabilities.append(vuln)
                    self.detected_sqli.append(vuln)
        
        # Also check response for SQL error messages
        if self._check_sql_errors(response.text):
            vuln = {
                "type": "SQL Error Disclosure",
                "severity": "Medium",
                "url": url,
                "detection_method": "error_message_analysis",
            }
            vulnerabilities.append(vuln)
            self.detected_sqli.append(vuln)
        
        return vulnerabilities

    def _test_sqli_payloads(
        self, url: str, param_name: str, original_value: str
    ) -> bool:
        """Test SQL injection payloads."""
        parsed_url = urlparse(url)
        base_params = parse_qs(parsed_url.query)
        
        # Test error-based payloads first
        test_payloads = self.SQLI_PAYLOADS[:8]  # Test first 8 payloads
        
        original_response = None
        try:
            original_response = self.session.get(url, timeout=10)
        except Exception:
            pass
        
        for payload in test_payloads:
            # Create test URL with payload
            test_params = {k: v[:] for k, v in base_params.items()}
            test_params[param_name] = [payload]
            
            from urllib.parse import urlencode, urlunparse
            test_url = urlunparse(parsed_url._replace(query=urlencode(test_params, doseq=True)))
            
            try:
                response = self.session.get(test_url, timeout=10)
                response_text = response.text
                
                # Check for SQL errors
                if self._check_sql_errors(response_text):
                    return True
                
                # Check for response differences (time-based)
                if original_response and response.elapsed.total_seconds() > original_response.elapsed.total_seconds() + 3:
                    return True
                    
            except Exception:
                continue
        
        return False

    def _check_sql_errors(self, content: str) -> bool:
        """Check content for SQL error patterns."""
        for pattern in self.SQL_ERROR_PATTERNS:
            if re.search(pattern, content, re.IGNORECASE):
                return True
        return False


class CSRFDetector:
    """
    Cross-Site Request Forgery (CSRF) detection.
    """

    CSRF_TOKEN_PATTERNS = [
        r'csrf[_-]?token',
        r'_token',
        r'authenticity[_-]?token',
        r'request[_-]?token',
        r'anti[_-]?csrf',
        r'nonce',
    ]

    STATE_CHANGING_METHODS = ['POST', 'PUT', 'DELETE', 'PATCH']

    def __init__(self, session: requests.Session):
        self.session = session
        self.detected_csrf: List[Dict[str, Any]] = []

    def detect_csrf(
        self, url: str, response: requests.Response, soup: BeautifulSoup
    ) -> List[Dict[str, Any]]:
        """
        Detect CSRF vulnerabilities.
        
        Args:
            url: Target URL
            response: HTTP response
            soup: Parsed BeautifulSoup object
            
        Returns:
            List of detected CSRF vulnerabilities
        """
        vulnerabilities = []
        
        # Check all forms for CSRF protection
        forms = soup.find_all('form')
        for i, form in enumerate(forms):
            form_action = form.get('action', '')
            form_method = form.get('method', 'GET').upper()
            
            # Focus on state-changing forms
            if form_method in self.STATE_CHANGING_METHODS:
                # Check for CSRF token in form
                has_csrf_token = self._check_form_csrf_token(form)
                
                # Check for CSRF token in cookies
                has_csrf_cookie = self._check_cookie_csrf_token(response)
                
                # Check for SameSite cookie attribute
                same_site = self._check_samesite_cookies(response)
                
                if not has_csrf_token and not has_csrf_cookie:
                    vuln = {
                        "type": "Cross-Site Request Forgery (CSRF)",
                        "severity": "High",
                        "form_action": form_action,
                        "form_method": form_method,
                        "form_index": i,
                        "url": url,
                        "detection_method": "form_analysis",
                        "missing_protection": "No CSRF token found in form or cookies",
                    }
                    vulnerabilities.append(vuln)
                    self.detected_csrf.append(vuln)
                elif same_site == 'None' or not same_site:
                    # Weak CSRF protection
                    vuln = {
                        "type": "Weak CSRF Protection",
                        "severity": "Medium",
                        "form_action": form_action,
                        "form_method": form_method,
                        "form_index": i,
                        "url": url,
                        "detection_method": "form_analysis",
                        "issue": "Missing or weak SameSite cookie attribute",
                    }
                    vulnerabilities.append(vuln)
                    self.detected_csrf.append(vuln)
        
        # Check for CSRF protection in API endpoints
        api_csrf = self._check_api_csrf_protection(url, response)
        if api_csrf:
            vulnerabilities.extend(api_csrf)
            self.detected_csrf.extend(api_csrf)
        
        return vulnerabilities

    def _check_form_csrf_token(self, form: BeautifulSoup) -> bool:
        """Check if form contains CSRF token."""
        # Check hidden inputs
        hidden_inputs = form.find_all('input', type='hidden')
        for inp in hidden_inputs:
            name = inp.get('name', '').lower()
            value = inp.get('value', '')
            if any(re.search(pattern, name) for pattern in self.CSRF_TOKEN_PATTERNS):
                if value:  # Has a non-empty value
                    return True
        
        return False

    def _check_cookie_csrf_token(self, response: requests.Response) -> bool:
        """Check if response sets CSRF token cookie."""
        cookies = response.headers.get('Set-Cookie', '')
        cookie_list = cookies.split(', ') if cookies else []
        
        for cookie in cookie_list:
            for pattern in self.CSRF_TOKEN_PATTERNS:
                if re.search(pattern, cookie, re.IGNORECASE):
                    return True
        
        return False

    def _check_samesite_cookies(self, response: requests.Response) -> Optional[str]:
        """Check SameSite cookie attribute."""
        cookies = response.headers.get('Set-Cookie', '')
        if 'SameSite=Strict' in cookies or 'SameSite=Lax' in cookies:
            return 'Strict'
        elif 'SameSite=None' in cookies:
            return 'None'
        return None

    def _check_api_csrf_protection(
        self, url: str, response: requests.Response
    ) -> List[Dict[str, Any]]:
        """Check CSRF protection for API endpoints."""
        vulnerabilities = []
        
        # Check if this is an API endpoint
        if re.search(r'/api/', url, re.IGNORECASE):
            # Check for Origin/Referer validation
            origin = response.headers.get('Access-Control-Allow-Origin', '')
            
            # Check for custom CSRF headers
            has_csrf_header = any(
                key in response.headers
                for key in ['X-CSRF-Token', 'X-Requested-With', 'X-XSRF-Token']
            )
            
            # Check for state-changing methods without CSRF protection
            if response.request.method in self.STATE_CHANGING_METHODS:
                if not has_csrf_header and origin == '*':
                    vuln = {
                        "type": "API CSRF Vulnerability",
                        "severity": "High",
                        "url": url,
                        "method": response.request.method,
                        "detection_method": "api_analysis",
                        "issue": "State-changing API endpoint lacks CSRF protection",
                    }
                    vulnerabilities.append(vuln)
        
        return vulnerabilities


class OpenRedirectDetector:
    """
    Open Redirect vulnerability detection.
    """

    REDIRECT_PAYLOADS = [
        '//evil.com',
        '/\\evil.com',
        'https://evil.com',
        'http://evil.com',
        '//attacker.com',
        '/https://evil.com',
        '/http://evil.com',
        '///evil.com',
        '////evil.com',
    ]

    def __init__(self, session: requests.Session):
        self.session = session
        self.detected_redirects: List[Dict[str, Any]] = []

    def detect_open_redirect(
        self, url: str, response: requests.Response, soup: BeautifulSoup
    ) -> List[Dict[str, Any]]:
        """
        Detect open redirect vulnerabilities.
        
        Args:
            url: Target URL
            response: HTTP response
            soup: Parsed BeautifulSoup object
            
        Returns:
            List of detected open redirect vulnerabilities
        """
        vulnerabilities = []
        parsed_url = urlparse(url)
        params = parse_qs(parsed_url.query)
        
        # Check URL parameters that commonly cause redirects
        redirect_params = [
            'url', 'redirect', 'return', 'returnTo', 'return_url',
            'next', 'next_page', 'destination', 'goto', 'link',
            'target', 'redir', 'forward', 'out', 'logout',
            'redirect_uri', 'redirect_url', 'returnurl', 'back'
        ]
        
        for param_name, param_values in params.items():
            if param_name.lower() in redirect_params:
                for param_value in param_values:
                    # Test with redirect payloads
                    redirect_found = self._test_redirect_payloads(url, param_name, param_value)
                    
                    if redirect_found:
                        vuln = {
                            "type": "Open Redirect",
                            "severity": "Medium",
                            "parameter": param_name,
                            "url": url,
                            "detection_method": "active_payload_testing",
                        }
                        vulnerabilities.append(vuln)
                        self.detected_redirects.append(vuln)
        
        # Also check for redirects in meta tags and JavaScript
        self._check_meta_redirects(soup, url, vulnerabilities)
        self._check_js_redirects(soup, url, vulnerabilities)
        
        return vulnerabilities

    def _test_redirect_payloads(
        self, url: str, param_name: str, original_value: str
    ) -> bool:
        """Test redirect payloads."""
        parsed_url = urlparse(url)
        base_params = parse_qs(parsed_url.query)
        
        for payload in self.REDIRECT_PAYLOADS:
            # Create test URL with payload
            test_params = {k: v[:] for k, v in base_params.items()}
            test_params[param_name] = [payload]
            
            from urllib.parse import urlencode, urlunparse
            test_url = urlunparse(parsed_url._replace(query=urlencode(test_params, doseq=True)))
            
            try:
                response = self.session.get(test_url, timeout=10, allow_redirects=False)
                
                # Check for redirects
                if response.status_code in [301, 302, 303, 307, 308]:
                    location = response.headers.get('Location', '')
                    # Check if redirect goes to our test domain
                    if 'evil.com' in location or 'attacker.com' in location:
                        return True
                        
            except Exception:
                continue
        
        return False

    def _check_meta_redirects(
        self, soup: BeautifulSoup, url: str, vulnerabilities: List[Dict[str, Any]]
    ):
        """Check for open redirects in meta refresh tags."""
        meta_refresh = soup.find('meta', attrs={'http-equiv': 'refresh'})
        if meta_refresh:
            content = meta_refresh.get('content', '')
            if re.search(r'url\s*=\s*["\']?[^"\']*\$', content, re.IGNORECASE):
                vuln = {
                    "type": "Open Redirect via Meta Refresh",
                    "severity": "Medium",
                    "url": url,
                    "detection_method": "static_analysis",
                }
                vulnerabilities.append(vuln)
                self.detected_redirects.append(vuln)

    def _check_js_redirects(
        self, soup: BeautifulSoup, url: str, vulnerabilities: List[Dict[str, Any]]
    ):
        """Check for open redirects in JavaScript."""
        scripts = soup.find_all('script')
        for script in scripts:
            if script.string:
                # Check for suspicious redirect patterns
                patterns = [
                    r'location\.href\s*=\s*[^;]*(\$\{|\$\(|window\.location)',
                    r'window\.location\s*=\s*[^;]*(\$\{|\$\()',
                    r'location\.replace\s*\([^)]*\$\{',
                ]
                for pattern in patterns:
                    if re.search(pattern, script.string, re.IGNORECASE):
                        vuln = {
                            "type": "Potential Open Redirect via JavaScript",
                            "severity": "Low",
                            "url": url,
                            "detection_method": "static_analysis",
                        }
                        vulnerabilities.append(vuln)
                        self.detected_redirects.append(vuln)
                        break


from urllib.parse import urlunparse
