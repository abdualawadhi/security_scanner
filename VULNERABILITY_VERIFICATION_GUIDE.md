# Vulnerability Verification Guide

## Overview

The Vulnerability Verification Engine provides **active security testing** capabilities to confirm the exploitability of detected vulnerabilities. This module performs controlled, safe exploitation attempts to upgrade vulnerability confidence levels from "Tentative" to "Firm" or "Certain".

⚠️ **IMPORTANT**: This module performs active security testing. Only use on systems you have explicit written permission to test. Unauthorized security testing may be illegal.

## Architecture

### Core Components

1. **VulnerabilityVerifier** (`verifier/vulnerability_verifier.py`)
   - Main verification engine
   - Supports multiple vulnerability types
   - Safe payload generation
   - Result confidence upgrading

2. **Verification Tests** (`verifier/verification_tests.py`)
   - Standalone test functions
   - Can be used independently
   - Modular and extensible

### Supported Vulnerability Types

| Vulnerability Type | Verification Method | Confidence Upgrade |
|-------------------|---------------------|-------------------|
| XSS (Cross-Site Scripting) | Payload reflection with unique markers | Tentative → Certain |
| SQL Injection | Time-based blind & error-based detection | Tentative → Certain |
| Command Injection | Time-based delay detection | Tentative → Certain |
| Path Traversal | File content markers | Tentative → Certain |
| SSRF | Internal URL access patterns | Tentative → Firm |
| Open Redirect | External URL redirection | Tentative → Certain |
| XXE | External entity injection | Tentative → Firm |
| CSRF | Token absence detection | Tentative → Firm |

## Usage

### Integration with Scanner

#### Via CLI

```bash
# Enable verification during scan
python -m website_security_scanner.cli.cli \
  --url https://target.com \
  --enhanced \
  --verify-vulnerabilities
```

#### Via Web Frontend

1. Navigate to "New Scan" page
2. Check "Verify Vulnerabilities" option
3. Start scan

Verification results will be included in the scan output and HTML report.

#### Programmatic Usage

```python
from website_security_scanner.verifier import VulnerabilityVerifier

# Initialize verifier
verifier = VulnerabilityVerifier()

# Verify a vulnerability
vulnerability = {
    'type': 'xss',
    'url': 'https://target.com/search',
    'parameter': 'q',
    'severity': 'high',
    'confidence': 'tentative'
}

result = verifier.verify_vulnerability(vulnerability)

print(f"Verified: {result['verified']}")
print(f"Confidence: {result['confidence']}")
print(f"Evidence: {result.get('evidence', 'N/A')}")
```

### Standalone Verification

```python
from website_security_scanner.verifier import verify_xss, verify_sql_injection

# Test XSS
xss_result = verify_xss(
    url='https://target.com/search',
    parameter='q'
)

# Test SQL Injection
sqli_result = verify_sql_injection(
    url='https://target.com/product',
    parameter='id'
)
```

## Verification Methods

### 1. Cross-Site Scripting (XSS)

**Method**: Safe payload reflection detection

**Payloads**:
```javascript
// Payloads use unique markers instead of actual XSS
<script>/*MARKER*/</script>
<img src=x onerror=/*MARKER*/>
"><script>/*MARKER*/</script>
```

**Verification Logic**:
1. Generate unique marker (MD5 hash)
2. Inject payload with marker
3. Check if marker is reflected unencoded
4. Upgrade confidence based on encoding status

**Result Confidence**:
- **Certain**: Payload reflected unencoded
- **Firm**: Payload reflected with encoding
- **Tentative**: No reflection detected

### 2. SQL Injection

**Method A**: Time-based blind detection

**Payloads**:
```sql
' OR SLEEP(5)--
' OR pg_sleep(5)--
'; WAITFOR DELAY '00:00:05'--
```

**Verification Logic**:
1. Send payload
2. Measure response time
3. If response takes 4-6 seconds → SQLi confirmed

**Method B**: Error-based detection

**Payloads**:
```sql
'
' OR '1'='1
' UNION SELECT NULL--
```

**Patterns to detect**:
- SQL syntax error messages
- Database-specific errors (MySQL, PostgreSQL, Oracle, MSSQL)

**Result Confidence**:
- **Certain**: SQL error messages or time delay confirmed
- **Firm**: Timeout suggests delay function execution
- **Tentative**: No indicators detected

### 3. Command Injection

**Method**: Time-based detection

**Payloads**:
```bash
; sleep 5
| sleep 5
& sleep 5
`sleep 5`
$(sleep 5)
```

**Verification Logic**:
1. Inject sleep command
2. Measure response time
3. Delay of 4-6 seconds confirms execution

**Result Confidence**:
- **Certain**: Time delay confirmed
- **Tentative**: No delay detected

### 4. Path Traversal

**Method**: File content detection

**Test Cases**:
```
../../../../etc/passwd → Check for: root:, bin:, daemon:
..\..\..\..\windows\win.ini → Check for: [fonts], [extensions]
../../../../proc/version → Check for: Linux, version
```

**Verification Logic**:
1. Attempt to read system files
2. Check for known content markers
3. Require 2+ markers for confirmation

**Result Confidence**:
- **Certain**: System file content detected
- **Tentative**: No file content found

### 5. SSRF (Server-Side Request Forgery)

**Method**: Internal URL access detection

**Test URLs**:
```
http://169.254.169.254/latest/meta-data/  # AWS metadata
http://127.0.0.1:80
http://localhost:22
```

**Verification Logic**:
1. Request internal URLs via target
2. Compare response with baseline
3. Check for AWS metadata content

**Result Confidence**:
- **Certain**: AWS metadata accessible
- **Firm**: Significant response difference
- **Tentative**: No SSRF indicators

### 6. Open Redirect

**Method**: External URL redirection

**Test URL**: `https://example.com`

**Verification Logic**:
1. Inject external URL in parameter
2. Check for 30x redirect status
3. Verify Location header points to external URL

**Result Confidence**:
- **Certain**: Redirects to external URL
- **Tentative**: No redirect detected

### 7. XXE (XML External Entity)

**Method**: External entity injection

**Payload**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/hostname">]>
<data>&xxe;</data>
```

**Verification Logic**:
1. Submit XXE payload
2. Check for file content in response

**Result Confidence**:
- **Firm**: Potential file content detected
- **Tentative**: No XXE indicators

### 8. CSRF (Cross-Site Request Forgery)

**Method**: Token absence detection

**Verification Logic**:
1. Check for CSRF token patterns in forms
2. Patterns: csrf_token, authenticity_token, __requestverificationtoken

**Result Confidence**:
- **Firm**: No CSRF tokens found
- **Tentative**: CSRF tokens present (needs further testing)

## Safety Considerations

### Safe Testing Practices

1. **Non-Destructive Payloads**
   - XSS: Uses comments instead of executing JavaScript
   - SQL: Time-based delays don't modify data
   - Command: Only uses safe sleep commands

2. **Timeouts**
   - All requests have 10-second timeout
   - Prevents resource exhaustion

3. **Rate Limiting**
   - Limited number of verification attempts
   - Respects target server resources

4. **No Data Modification**
   - Verification only reads/tests
   - No DELETE, UPDATE, or destructive operations

### Ethical Guidelines

✅ **DO**:
- Get written permission before testing
- Test only systems you own or have authorization for
- Document all testing activities
- Report findings responsibly
- Use verification to confirm legitimate findings

❌ **DON'T**:
- Test production systems without approval
- Use verification for malicious purposes
- Exceed authorized scope
- Attempt to exploit beyond verification
- Share credentials or access obtained

## Configuration

### Verification Settings

Modify in `vulnerability_verifier.py`:

```python
class VulnerabilityVerifier:
    def __init__(self):
        self.verification_timeout = 10  # Request timeout
        self.max_retries = 2            # Retry attempts
```

### Custom Payloads

Add custom payloads for specific vulnerability types:

```python
def verify_custom(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
    """Custom verification method"""
    # Your verification logic here
    return {
        'verified': True,
        'confidence': 'certain',
        'method': 'custom_verification',
        'evidence': 'Detailed evidence here'
    }

# Register in verify_vulnerability method
verification_methods = {
    'custom_vuln_type': self.verify_custom,
    # ... other methods
}
```

## Verification Results

### Result Structure

```python
{
    'verified': bool,              # True if vulnerability confirmed
    'confidence': str,             # 'certain', 'firm', or 'tentative'
    'method': str,                 # Verification method used
    'payload': str,                # Payload that confirmed vulnerability
    'evidence': str,               # Description of evidence
    'verification_details': dict,  # Additional technical details
    'reason': str                  # Explanation (if not verified)
}
```

### Confidence Levels

- **Certain**: High confidence, exploitation confirmed
- **Firm**: Moderate confidence, strong indicators present
- **Tentative**: Low confidence, unverified or inconclusive

### In Reports

Verification results appear in HTML reports:

```html
<div class="verification-status">
    <span class="font-semibold">Verified:</span> 
    <span class="text-green-600">Yes</span>
    <span class="text-sm">(certain confidence)</span>
</div>
```

## Performance Considerations

### Time Impact

- Each verification adds ~2-10 seconds per vulnerability
- Time-based tests are slowest (5+ seconds)
- Batch verification processes sequentially

### Optimization Tips

1. **Selective Verification**
   - Only verify high/critical severity findings
   - Skip verification for informational findings

2. **Parallel Verification** (Future Enhancement)
   ```python
   # Not yet implemented
   from concurrent.futures import ThreadPoolExecutor
   
   with ThreadPoolExecutor(max_workers=5) as executor:
       results = executor.map(verify_vulnerability, vulnerabilities)
   ```

3. **Caching**
   - Cache verification results
   - Avoid re-verifying identical vulnerabilities

## Extending Verification

### Adding New Vulnerability Types

1. **Create Verification Method**

```python
def verify_new_vuln_type(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
    """
    Verify NEW_VULN_TYPE vulnerability.
    """
    url = vulnerability.get('url', '')
    param = vulnerability.get('parameter', '')
    
    # Your verification logic
    try:
        # Test the vulnerability
        response = self.session.get(url, timeout=self.verification_timeout)
        
        # Check for vulnerability indicators
        if some_condition:
            return {
                'verified': True,
                'confidence': 'certain',
                'method': 'your_method',
                'evidence': 'Evidence description'
            }
    except Exception as e:
        logger.debug(f"Verification failed: {e}")
    
    return {
        'verified': False,
        'confidence': 'tentative',
        'reason': 'No indicators detected'
    }
```

2. **Register in verify_vulnerability**

```python
verification_methods = {
    # ... existing methods
    'new_vuln_type': self.verify_new_vuln_type,
}
```

3. **Add Tests**

```python
# In verification_tests.py
def verify_new_vuln_type(url: str, parameter: str, 
                         session: Optional[requests.Session] = None) -> Dict[str, Any]:
    """Standalone verification test."""
    from .vulnerability_verifier import VulnerabilityVerifier
    verifier = VulnerabilityVerifier(session)
    return verifier.verify_new_vuln_type({
        'url': url,
        'parameter': parameter,
        'type': 'new_vuln_type'
    })
```

## Troubleshooting

### Common Issues

1. **Timeouts**
   - Increase `verification_timeout`
   - Check network connectivity
   - Target may be blocking requests

2. **False Negatives**
   - WAF/IPS may be blocking payloads
   - Target may have specific protections
   - Try alternative payloads

3. **False Positives**
   - Time-based tests can be affected by network latency
   - Adjust delay thresholds
   - Use multiple verification methods

### Debug Mode

Enable detailed logging:

```python
import logging
logging.basicConfig(level=logging.DEBUG)
```

## Legal & Compliance

### Authorization Requirements

Before using verification features:
1. Obtain written permission from system owner
2. Define scope of testing
3. Agree on testing timeframe
4. Establish communication channels
5. Document all authorization

### Compliance Frameworks

Verification features support:
- **OWASP Testing Guide**: Active security testing
- **PTES**: Vulnerability validation phase
- **NIST SP 800-115**: Technical security assessment
- **PCI DSS**: Requirement 11.3 (penetration testing)

### Reporting

When reporting verified vulnerabilities:
1. Include verification evidence
2. Document payload used
3. Provide reproduction steps
4. Assess business impact
5. Recommend remediation

## References

- [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide/)
- [PortSwigger Web Security Academy](https://portswigger.net/web-security)
- [MITRE CWE](https://cwe.mitre.org/)
- [NIST SP 800-115](https://csrc.nist.gov/publications/detail/sp/800-115/final)

---

**Remember**: With great power comes great responsibility. Use verification features ethically and legally.
